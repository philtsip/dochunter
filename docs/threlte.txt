[{"url":"https://threlte.xyz/docs/examples/examples","title":"Examples | Threlte Example","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex Search Misc Gaussian Splatting Tutorials Animating a Spaceship animation Animation Transitions camera Pointer Lock Controls ThirdPersonCamera camera-controls geometry LOD Random Placement Rendering Points Terrain with 3D noise Terrain with Rapier physics meshline Cursor Lines postprocessing Outlines renderers CSS2DRenderer Overlay shaders Interactive shader Examples There are a ton of different challenges and things to consider when creating a 3D project. Here you will find recipes and inspiration to get started with Threlte. Help Wanted We’d love your help to make, add to and edit the examples. There lots of examples from three.js and r3f that could serve as inspiration. Read through the contributing guide and Examples README to get started. Next Page Gaussian Splatting Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/learn/advanced/plugins","title":"Plugins | Learn Threlte","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex Search Getting Started Introduction Installation Your First Scene Basics App Structure Scheduling Tasks Handling Events Loading Assets Render Modes Disposing Objects Advanced Plugins Custom Abstractions Migration Guides More Resources Advanced Plugins Injecting a Plugin What it looks like Plugins open up the component <T> to external code that will be injected via context into every child instance of a <T> component. Copy import { injectPlugin } from '@threlte/core' injectPlugin('plugin-name', ({ ref, props }) => { console.log(ref, props) }) If a plugin decides via ref or props analysis that it doesn’t need to act in the context of a certain <T> component, it can return early. Copy import { injectPlugin } from '@threlte/core' import type { Object3D } from 'three' const refIsObject3D = (ref: any): ref is Object3D => ref.isObject3D injectPlugin('raycast-plugin', ({ ref, props }) => { if (!refIsObject3D(ref) || !props.raycast) return }) The code of a plugin acts as if it would be part of the <T> component itself and has access to all properties. A plugin is notified about property or ref changes and can run code in lifecycle functions such as onMount or onDestroy. Copy import { injectPlugin } from '@threlte/core' import { onMount } from 'svelte' injectPlugin('plugin-name', () => { // Use lifecycle hooks as if it would run inside a <T> component. onMount(() => { console.log('onMount') }) return { // This is called when the ref changes and on initialization. onRefChange(ref) { console.log(ref) // You can return a cleanup function that will be called when the ref // changes again or when the component is destroyed. return () => { console.log('cleanup') } }, // This is called when the props change and on initialization. This includes // props like \"args\", \"manual\" and other base props of <T> but also // props that are not part of the base props. onPropsChange(props) { console.log(props) }, // This is called when the props change that are not part of the <T> // components base props and on initialization. onRestPropsChange(restProps) { console.log(restProps) } } }) It can also claim properties so that the component <T> does not act on it. Copy import { injectPlugin } from '@threlte/core' injectPlugin('ecs', () => { return { // without claiming the property \"position\", <T> would apply the // property to the object pluginProps: ['entity', 'health', 'velocity', 'position'] } }) Plugins are passed down by context and can be overridden to prevent the effects of a plugin for a certain tree. Copy import { injectPlugin } from '@threlte/core' // this overrides the plugin with the name \"plugin-name\" for all child components. injectPlugin('plugin-name', () => {}) Creating a Plugin Plugins can also be created for external consumption. This creates a named plugin. The name is used to identify the plugin and to override it. Copy import { createPlugin } from '@threlte/core' export const layersPlugin = createPlugin('layers', () => { // ... Plugin Code }) Copy // somewhere else, e.g. in a component import { injectPlugin } from '@threlte/core' import { layersPlugin } from '$plugins' injectPlugin(layersPlugin) Examples lookAt  This is en example implementation that adds the property lookAt to all <T> components, so that <T.Mesh lookAt={[0, 10, 0]} /> is possible:  Show Code App.svelte lookAtPlugin.ts Scene.svelte Copy <script lang=\"ts\">   import { Canvas } from '@threlte/core'   import Scene from './Scene.svelte' </script> <div>   <Canvas>     <Scene />   </Canvas> </div> <style>   div {     height: 100%;   } </style> BVH Raycast Plugin  A Plugin that implements BVH raycasting on all child meshes and geometries.  Copy <script lang=\"ts\">   import { injectPlugin } from '@threlte/core'   import type { BufferGeometry, Mesh } from 'three'   import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh'   const isBufferGeometry = (ref: any): ref is BufferGeometry => {     return ref.isBufferGeometry   }   const isMesh = (ref: any): ref is Mesh => {     return ref.isMesh   }   injectPlugin('bvh-raycast', () => {     return {       onRefChange(ref) {         if (isBufferGeometry(ref)) {           ;(ref as any).computeBoundsTree = computeBoundsTree           ;(ref as any).disposeBoundsTree = disposeBoundsTree           ;(ref as any).computeBoundsTree()         }         if (isMesh(ref)) {           ;(ref as any).raycast = acceleratedRaycast         }         return () => {           if (isBufferGeometry(ref)) {             ;(ref as any).disposeBoundsTree()           }         }       }     }   }) </script> <slot />  Implementing this plugin in your Scene:  Copy <script lang=\"ts\">   import { Canvas } from '@threlte/core'   import BvhRaycast from './plugins/BvhRaycast.svelte'   import Scene from './Scene.svelte' </script> <Canvas>   <BvhRaycast>     <Scene />   </BvhRaycast> </Canvas> Threlte-managed Matrix Updates  By default, Three.js is automatically updating the matrix and matrixWorld properties of all objects every frame. This can be a performance problem in large apps, because it is not necessary in certain situations. This plugin listens for changes to certain transform-related properties and updates the matrix and matrixWorld properties only when necessary.  Copy <script lang=\"ts\">   import { Object3D } from 'three'   import { injectPlugin, useTask, useThrelte } from '@threlte/core'   const { invalidate } = useThrelte()   const isObject3D = (obj: any): obj is Object3D => {     return obj.isObject3D   }   const propKeysRequiringMatrixUpdate = [     'position',     'position.x',     'position.y',     'position.z',     'rotation',     'rotation.x',     'rotation.y',     'rotation.z',     'rotation.order',     'quaternion',     'quaternion.x',     'quaternion.y',     'quaternion.z',     'quaternion.w',     'scale',     'scale.x',     'scale.y',     'scale.z'   ]   const objectsToUpdate: Set<Object3D> = new Set()   type MatrixPluginProps = {     matrixAutoUpdate?: boolean   }   injectPlugin<MatrixPluginProps>('matrix-update', ({ ref, props }) => {     if (!isObject3D(ref)) return     if (props.matrixAutoUpdate) return     ref.matrixAutoUpdate = false     const checkForMatrixUpdate = (props: Record<string, any>) => {       if (Object.keys(props).some((key) => propKeysRequiringMatrixUpdate.includes(key))) {         objectsToUpdate.add(ref)       }     }     checkForMatrixUpdate(props)     return {       pluginProps: ['matrixAutoUpdate'],       onRestPropsChange(restProps) {         checkForMatrixUpdate(restProps)       }     }   })   useTask(     () => {       if (!objectsToUpdate.size) return       objectsToUpdate.forEach((obj) => obj.updateMatrix())       objectsToUpdate.clear()       invalidate()     },     {       autoInvalidate: false     }   ) </script> <slot />  Now when applying props like position.x or scale to any <T> component, the matrix of the object will update but doesn’t just update every frame as Three.js does by default. If an object is transformed without props (like a camera being transformed by THREE.OrbitControls) you can apply the flag matrixAutoUpdate:  Copy <T.PerspectiveCamera   matrixAutoUpdate   makeDefault >   <OrbitControls /> </T.PerspectiveCamera>  Notice how this plugin uses TypeScript to augment to possible props this plugin may receive. This is not necessary, but it is a good practice to do so.  Previous Page Disposing Objects Next Page Custom Abstractions On this page Injecting a Plugin What it looks like Creating a Plugin Examples lookAt BVH Raycast Plugin Threlte-managed Matrix Updates Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/learn/more/resources","title":"Resources | Learn Threlte","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  Getting Started Introduction Installation Your First Scene Basics App Structure Scheduling Tasks Handling Events Loading Assets Render Modes Disposing Objects Advanced Plugins Custom Abstractions Migration Guides More Resources More Resources  This is a curated list of invaluable resources that will assist you in mastering Threlte and its underlying technologies. Whether you are a beginner looking to get started or an experienced developer seeking advanced knowledge, these resources offer a wealth of information to level up your skills.  Underlying Libraries  The following libraries are foundational to understanding Threlte’s architecture and functionalities:  Three.js  An excellent starting point for 3D graphics on the web. Three.js serves as the backbone for rendering and creating 3D scenes in Threlte.  Rapier  An essential library for real-time physics simulations. Rapier helps bring your Threlte projects to life with dynamic interactions.  Theatre.js  Focuses on timeline-based animations and offers intricate control over complex animations, making it easier to manage complex state changes in Threlte.  GLSL Resources  GLSL (Graphics Library Shader Language) is a critical part of shader programming, which is central to achieving high-quality visual effects in Threlte.  The Book of Shaders  This resource breaks down complex shader programming into bite-sized lessons. A great starting point for anyone new to shaders.  Learn OpenGL  An in-depth resource for learning OpenGL and GLSL, covering topics from beginner to advanced levels. Learn OpenGL offers tutorials that are easily applicable to Threlte’s context.  We hope you find these resources valuable in your journey to mastering Threlte. Happy Learning!  Previous Page Migration Guides On this page Underlying Libraries Three.js Rapier Theatre.js GLSL Resources The Book of Shaders Learn OpenGL Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/reference/xr/getting-started","title":"Getting Started | @threlte/xr","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  @threlte/xr Getting Started COMPONENTS <XR> <VRButton> <ARButton> <XRButton> <Controller> <Hand> <Headset> CONTROLS pointerControls teleportControls HOOKS useXR useController useHand useHandJoint useHeadset useHitTest useTeleport @threlte/xr Getting Started  The package @threlte/xr provides tools and abstractions to more easily create VR and AR experiences.  Installation Terminal Copy npm install @threlte/xr Usage  @threlte/xr is in beta. Major API changes at this point are not expected, but some breaking changes may occur before it reaches 1.0.0.  Setup  The following adds a button to start your session and controllers inside an XR manager to prepare your scene for WebXR rendering and interaction.  Scene.svelte Copy <script>   import { Canvas } from '@threlte/core'   import { VRButton } from '@threlte/xr'   import Scene from './scene.svelte' </script> <Canvas>   <Scene /> </Canvas> <VRButton />  Then, in scene.svelte:  Copy <script>   import { XR, Controller, Hand } from '@threlte/xr' </script> <XR /> <Controller left /> <Controller right /> <Hand left /> <Hand right />  This will set up your project to be able to enter a VR session with controllers and hand inputs added.  If you want hands, controllers, or any other objects to be added to your THREE.Scene only when the XR session starts, make them children of the <XR> component:  Copy <script>   import { XR, Controller, Hand } from '@threlte/xr' </script> <XR>   <Controller left />   <Controller right />   <Hand left />   <Hand right /> </XR>  The <XR>, <Controller>, and <Hand> components can provide a powerful foundation when composed with other Threlte components.  For example, it doesn’t take much more to get to the point of a simple BeatSaber-inspired experience:  Show Code App.svelte Blocks.svelte Sabers.svelte Scene.svelte Copy <script lang=\"ts\">   import { Canvas } from '@threlte/core'   import { World } from '@threlte/rapier'   import { VRButton } from '@threlte/xr'   import Scene from './Scene.svelte' </script> <div>   <Canvas>     <World gravity={[0, 0, 0]}>       <Scene />     </World>   </Canvas>   <VRButton /> </div> <style>   div {     height: 100%;   } </style> Previous Page sheetObjectAction Next Page Components On this page Installation Usage Setup Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/reference/extras/getting-started","title":"Getting Started | @threlte/extras","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  @threlte/extras Getting Started COMPONENTS <InstancedMesh> <Instance> <InstancedMeshes> <AudioListener> <Audio> <PositionalAudio> <RoundedBoxGeometry> <AnimatedSpriteMaterial> <ContactShadows> <Float> <CSM> <Edges> <Gizmo> <Grid> <Text> <HTML> <Environment> <OrbitControls> <TrackballControls> <TransformControls> <Portal> <PortalTarget> <GLTF> <Align> <Sky> <SoftShadows> <Suspense> <MeshLineGeometry> <MeshLineMaterial> HOOKS useGltf useCursor useGamepad useGltfAnimations useProgress useTexture useAudioListener useThrelteAudio useSuspense LIFECYCLE onReveal onSuspend PLUGINS layers interactivity transitions @threlte/extras Getting Started  The package '@threlte/extras' provides useful utilities, abstractions and plugins for your Threlte application.  Installation Terminal Copy npm install @threlte/extras Usage  The content of this package can be used directly but it’s also meant to be a recipe for creating your own abstractions and plugins depending on your use case.  Components  Most components are abstractions of one or more <T> components and forward all props and event listeners to it.  Let’s look at an example, the <OrbitControls>. They are a common component in Three.js applications and can be used to easily manipulate the camera. Let’s implement it:  Scene.svelte Copy <script>   import { OrbitControls } from '@threlte/extras'   import { T } from '@threlte/core' </script> <T.PerspectiveCamera   makeDefault   position={[5, 5, 5]} >   <OrbitControls /> </T.PerspectiveCamera>  In a regular Three.js application, you would have to create a OrbitControls instance by passing the camera and a DOM element to it. In Threlte, you can just use the <OrbitControls> component and it will automatically use the default camera and the <canvas> element the renderer is rendering to. It will also automatically invalidate the frame on demand.  Under the hood though, there’s still a regular <T> component that is doing the work of applying props and registering event listeners. Internally, <OrbitControls> is forwarding all props and event listeners, so you can use it just like a regular <T> component.  Let’s add an event listener that’s called when the camera is moved:  Scene.svelte Copy <script>   import { OrbitControls } from '@threlte/extras'   import { T } from '@threlte/core' </script> <T.PerspectiveCamera   makeDefault   position={[5, 5, 5]} >   <OrbitControls     on:change={(e) => {       console.log(e)     }}   /> </T.PerspectiveCamera>  The event listener is forwarded to the <T> component and will be called when the camera is moved. Keep in mind that these events are not hand-wired in the component, but are forwarded to the underlying <T> component which in turn forwards them to the Three.js object. So you can use any event listener that is supported by the <T> component.  Plugins  The package also provides a few plugins that can be used to extend the functionality of Threlte and <T> components. The most notable one is probably the plugin interactivity that provides a way to interact with the scene. We can extend our example from above and implement interactivity:  Scene.svelte Copy <script>   import { OrbitControls, interactivity } from '@threlte/extras'   import { T } from '@threlte/core'   interactivity() </script> <T.PerspectiveCamera   makeDefault   position={[5, 5, 5]} >   <OrbitControls /> </T.PerspectiveCamera> <T.Mesh   on:click={() => {     console.log('clicked')   }} >   <T.BoxGeometry />   <T.MeshBasicMaterial color=\"red\" /> </T.Mesh>  Now, when we click on the box, we will see a message in the console. The interactivity plugin registers a global event listener on the <canvas> element and forwards all events to the respective <T> components. Check out the guide on events for more information on how to use events in Threlte.  Plugins are injected via context and therefore need to be implement at the root of your application, this is typically your Scene.svelte component. Check out our recommended app structure.  Hooks  Hooks are regular functions with the limitation that they can only be invoked from the top level of a component. '@threlte/extras' provides useful hooks for loading assets, creating animations and more. Let’s look at an example where we use the hook useGltf to load an asset:  Scene.svelte Copy <script>   import { useGltf } from '@threlte/extras'   import { T } from '@threlte/core'   // Place the model in your public folder   const model = useGltf('/model.glb') </script>  The hook will return the special Threlte store AsyncWritable that makes it easy to consume the result of the loader. The store will be updated once the asset is loaded and can be used in the template either with the {#await} or the {#if} block. Let’s use the {#await} block to display a loading message:  Scene.svelte Copy <script>   import { useGltf } from '@threlte/extras'   import { T } from '@threlte/core'   import LoadingPlaceholder from './LoadingPlaceholder.svelte'   const model = useGltf('/model.glb') </script> {#await model}   <LoadingPlaceholder /> {:then value}   <T is={value} /> {/await}  Keep in mind that the hook useGltf caches the result as it’s using useLoader internally.  Previous Page useRender Next Page Components On this page Installation Usage Components Plugins Hooks Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/reference/core/t","title":"<T> | @threlte/core","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  @threlte/core Getting Started COMPONENTS <Canvas> <T> HOOKS useThrelte useStage useTask useLoader useThrelteUserContext HELPERS Plugins Utilities Hierarchy LEGACY useFrame useRender @threlte/core <T>  The component <T> provides the means to use any three.js export as a Svelte component. It does this by leveraging the rigid three.js naming and object property structure to add and remove objects to and from the scene graph, attach objects to parent object properties or add event listeners.  <T> is the main building block of any Threlte application. Components available in '@threlte/extras' are built on top of <T> and may provide a more convenient API for specific three.js classes.  Usage Types  Primer on Terminology  There are two ways to use <T>:  Use dot-notation to use any three.js class available at Three.js’ main namespace 'three': Copy <script>   import { T } from '@threlte/core' </script> <T.Mesh /> Pass the property is to <T>: Copy <script>   import { T } from '@threlte/core'   import { Mesh } from 'three' </script> <T is={Mesh} />  Both ways are equivalent and can be used interchangeably. The latter is more explicit and allows you to use any class definition (even if it’s not exported from Three.js’ main namespace 'three'), object instance or virtually any other value.  The next section will discuss both ways in more detail.  Dot-Notation  Any three.js class available at Three.js’ main namespace 'three' can be used as a component with full type-safety. The name of the import is the same as the name of the component. For example, the class THREE.Mesh can be used with the component <T.Mesh>. Let’s take a look at a simple example:  Copy <script>   import { T } from '@threlte/core' </script> <T.Mesh>   <T.BoxGeometry />   <T.MeshBasicMaterial /> </T.Mesh>  Let’s break this down:  The component <T.Mesh> creates an instance of THREE.Mesh which is automatically added to the scene graph. The component <T.BoxGeometry> creates an instance of THREE.BoxGeometry which is automatically “attached” to the property geometry of the parent THREE.Mesh. The component <T.MeshBasicMaterial> creates an instance of THREE.MeshBasicMaterial which is automatically “attached” to the property material of the parent THREE.Mesh. Extend the default component catalogue  If you want to use a class that is not available at Three.js’ main namespace 'three' with dot-notation, you can extend the default component catalogue. Be aware that components used this way do not offer type-safety. Once extended, the updated catalogue is available to all components in your application.  Camera.svelte Copy <script>   import { T, extend, useThrelte } from '@threlte/core'   import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'   extend({     OrbitControls   })   const { renderer } = useThrelte() </script> <T.PerspectiveCamera   let:ref   makeDefault >   <T.OrbitControls args={[ref, renderer.domElement]} /> </T.PerspectiveCamera> Property is  To explicitly pass a class definition to the component <T>, use the property is. Let’s take a look at the same example as above but using the property is:  Copy <script>   import { T } from '@threlte/core'   import { Mesh, BoxGeometry, MeshBasicMaterial } from 'three' </script> <T is={Mesh}>   <T is={BoxGeometry} />   <T is={MeshBasicMaterial} /> </T>  The two examples are equivalent and can be used interchangeably.  The “vanilla” Three.js equivalent of both examples would be:  Copy import { Mesh, BoxGeometry, MeshBasicMaterial } from 'three' const mesh = new THREE.Mesh(new THREE.BoxGeometry(), new THREE.MeshBasicMaterial()) scene.add(mesh)  Using the property is comes in handy when using classes that are not exported from Three.js’ main namespace 'three', such as the OrbitControls class:  Copy <script>   import { T } from '@threlte/core'   import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls' </script> <T is={OrbitControls} /> What’s happening under the hood?  If a class definition such as THREE.Mesh is provided to the property is, it creates an instance of that class which we call ref – the component’s reference to the three.js object:  Copy <T is={Mesh} />  If a class instance (such as new THREE.Mesh()) or any other value is provided, the component uses this value as-is:  Copy <script>   const mesh = new Mesh() </script> <T is={mesh} />  Depending on the is property value types, Threlte makes certain assumptions:  If the value passed to is is extending THREE.Object3D it’s added to the scene graph. If the value passed to is is a disposable, it’s disposed onDestroy or whenever the args change and a new ref is created. If the value passed to is is has a property addEventListener, you can add event callbacks. If the value passed to is is extending THREE.Camera, certain camera-related properties are available. Props  The <T> component has a set of fixed props (namely args, is, attach, manual, makeDefault and dispose) that are used to set up the Three.js object. On top of that, you can use arbitrary props to reactively set any property of the underlying Three.js object.  Three.js object props  To understand how it works, let’s have a look at a simple example. Let’s say we want to render a simple cube. We can do this by using the <T> component:  Copy <script>   import { T } from '@threlte/core' </script> <T.Mesh>   <T.BoxGeometry />   <T.MeshBasicMaterial /> </T.Mesh>  Using attachments, the geometry as well as the material are assigned to the mesh. What if we want to change the color of the material to \"red\"? We can do this by using the color prop:  Copy <script>   import { T } from '@threlte/core' </script> <T.Mesh>   <T.BoxGeometry />   <T.MeshBasicMaterial color=\"red\" /> </T.Mesh>  Keep in mind that this property is not hard-wired. We can use any property of the underlying Three.js object as a prop on the <T> component. For example, we can also set the position property of the THREE.Mesh:  Copy <script>   import { T } from '@threlte/core' </script> <T.Mesh position={[0, 1, 0]}>   <T.BoxGeometry />   <T.MeshBasicMaterial color=\"red\" /> </T.Mesh>  Because the property position of a THREE.Mesh is a THREE.Vector3 the value we have to provide is what is passed to the set function of the THREE.Vector3 class. In this case, we pass an array of three numbers ([x, y, z]). Using an editor like VS Code, you benefit from type hints and auto-completion.  We only changed the y coordinate of the position, so we can use a pierced prop to only change the y coordinate:  Copy <script>   import { T } from '@threlte/core' </script> <T.Mesh position.y={1}>   <T.BoxGeometry />   <T.MeshBasicMaterial color=\"red\" /> </T.Mesh>  This way, we get less updates of the underlying Three.js object because the value of the prop is a primitive value which can easily be compared to the previous value. Unfortunately with pierced props we miss out on the type hints and auto-completion.  Constant prop types  The type of an inferred prop (or “auto prop”) must be constant. This means that the type of a prop must not change for the lifetime of the component. For instance you can’t use a variable as a prop that is an array of numbers and then later on change the value of that variable to a single number. This is considered a type change and therefore not allowed.  args  Three.js objects are class instances. When Instantiating these objects, they can receive one-time constructor arguments (new THREE.SphereGeometry(1, 32)). In Threlte, constructor arguments are always passed as an array via the property args. If args change later on, the object must naturally get reconstructed from scratch!  If a class definition such as THREE.BoxGeometry is provided to the property is, the property args is used to instantiate the class: <T is={BoxGeometry} args={[1, 2, 1]}> equals new BoxGeometry(1, 2, 1). attach  Use attach to bind objects to their parent. If you unmount the attached object it will be taken off its parent automatically.  The following attaches a material to the material property of a mesh and a geometry to the geometry property:  Copy <T.Mesh>   <T.MeshBasicMaterial attach=\"material\" />   <T.BoxGeometry attach=\"geometry\" /> </T.Mesh>  All objects ending with “Material” (such as MeshStandardMaterial) receive attach=\"material\", and all objects ending with “Geometry” receive attach=\"geometry\" automatically. You do not strictly have to type it out!  The value inferred from the property is is “attached” to a parent property. Copy <script>   import { MeshStandardMaterial } from 'three'   export let texture </script> <T is={MeshStandardMaterial}>   <!-- Attaches the texture to the property \"map\" of the parent material -->   <T     is={texture}     attach=\"map\"   /> </T> attach can be a dot-notated path to a nested parent property: Copy <T is={DirectionalLight}>   <!--     Attaches an instance of a THREE.OrthographicCamera     to the property camera of the property shadow of the     parent THREE.DirectionalLight   -->   <T     is={OrthographicCamera}     args={[-1, 1, 1, -1, 0.1, 100]}     attach=\"shadow.camera\"   /> </T> attach can also be a function which is called on mounting with the parent and the value inferred from the property is. It can return a cleanup function which is called onDestroy: Copy <T is={DirectionalLight}>   <!--     Attaches an instance of a THREE.OrthographicCamera     to the property camera of the property shadow of the     parent THREE.DirectionalLight   -->   <T     is={OrthographicCamera}     args={[-1, 1, 1, -1, 0.1, 100]}     attach={(parent, self) => {       parent.shadow.camera = self       return () => {         parent.shadow.camera = null       }     }}   /> </T> Camera Props  By default Threlte is responsive and will set up cameras properly on resize (aspect ratio etc). Cameras can be controlled manually by setting manual to true. This will opt out of projection matrix recalculation when the drawing area resizes or other camera-related properties change.  Copy <T   is={PerspectiveCamera}   manual />  Use the property makeDefault to set a camera to the default rendering camera.  Copy <T   is={PerspectiveCamera}   makeDefault />  A common mistake is to forget setting makeDefault. If you do not set a camera to be the default camera, the scene will not be rendered through this camera but through Threltes default camera.  Events  Adding an event listener to a component will also add the corresponding event listener to the three.js class instance. The event will be forwarded and the native payload is available as the first argument to the event listener.  For easier payload access as well as conforming to Three.js as much as possible, Threlte does not use Svelte’s CustomEvent<Payload> payload type. Instead, the payload is provided as is.  This will listen to the “change” event on the THREE.OrbitControls:  Copy <T   is={OrbitControls}   on:change={(e) => console.log('change:', e)} />  All <T> components also emit the create event when the underlying three.js class instance is created. This can be used to access the instance from the parent component or do tasks on the objects upon creation. The event handler is called with an object containing a reference to the object as well as a function cleanup that you may invoke with a callback to clean up after the object is destroyed when the component unmounts or the args change.  Copy <T.PerspectiveCamera   on:create={({ ref, cleanup }) => {     // Look at the center     ref.lookAt(0, 0, 0)     cleanup(() => {       // Do something when the camera is disposed     })   }} /> Slot Props  The value infered from the property is is available as the slot prop ref:  Copy <T.PerspectiveCamera let:ref={camera}>   <!--     The slot prop \"ref\" is used to reference the     camera and instantiate the OrbitControls   -->   <T     is={OrbitControls}     args={[camera, renderer.domElement]}   /> </T.PerspectiveCamera> Bindings  The value infered from the property is is available as the binding ref:  Copy <script>   let camera   $: console.log(camera) // THREE.PerspectiveCamera </script> <T   is={PerspectiveCamera}   bind:ref={camera} /> <!-- or --> <T.PerspectiveCamera bind:ref={camera} /> Extending the default component catalogue  By default when using the dot-notation to access Three.js objects (e.g. <T.Mesh>), Threlte will automatically import the corresponding class from the namespance 'three'. If you want to use a custom class or classes from Three.js that are available elsewhere (like OrbitControls), you can extend the default catalogue with the extend function:  Copy <script>   import { extend, T } from '@threlte/core'   import { CustomMesh } from './MyCustomMesh.ts'   import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'   extend({     CustomMesh   }) </script> <T.CustomMesh />  Be aware that in this case <T> can’t provide type-safety on properties and events. If you need type-safety, you can use the is property instead: <T is={CustomMesh} />. This way, Threlte can infer the type of the object and provide type-safety on properties and events.  Previous Page <Canvas> Next Page Hooks On this page Usage Types Dot-Notation Property is Props Three.js object props args attach Camera Props Events Slot Props Bindings Extending the default component catalogue Contribute Contribution Guide Go To Source Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/learn/basics/render-modes","title":"Render Modes | Learn Threlte","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  Getting Started Introduction Installation Your First Scene Basics App Structure Scheduling Tasks Handling Events Loading Assets Render Modes Disposing Objects Advanced Plugins Custom Abstractions Migration Guides More Resources Basics Render Modes  Threlte offers three different render modes to optimize the performance and power usage of your Threlte app. Ideally, you only want to render the scene when it is necessary, such as when the camera moves or when objects are added or removed from the scene. The render mode determines how and when the scene is rendered.  In the default 'on-demand' mode, Threlte is able to determine when a re-render is necessary by observing components. When setting the render mode to 'manual' you must manually trigger a re-render. You can tell Threlte to continuously render the scene in the 'always' mode.  Mode 'on-demand' Show Code App.svelte RenderIndicator.svelte Scene.svelte Copy <script lang=\"ts\">   import { Canvas } from '@threlte/core'   import RenderIndicator from './RenderIndicator.svelte'   import Scene from './Scene.svelte' </script> <div class=\"wrapper\">   <Canvas>     <Scene />     <RenderIndicator />   </Canvas>   <div class=\"description\">     <p>       <strong>Click and drag</strong> to rotate the camera.     </p>     <p>       <strong>Hover</strong> over the sphere to scale it up.     </p>   </div> </div> <style>   div.wrapper {     height: 100%;   }   div.description {     position: absolute;     bottom: 10px;     left: 10px;     z-index: 10;     color: #fe3d00;   } </style> Copy <script lang=\"ts\">   import { useStage, useTask, useThrelte } from '@threlte/core'   import { Pane, WaveformMonitor } from 'svelte-tweakpane-ui'   const { shouldRender, renderStage } = useThrelte()   const afterRenderStage = useStage('after-render', {     after: renderStage   })   let log = Array(100).fill(0)   useTask(     () => {       log = update(log)     },     {       autoInvalidate: false,       stage: afterRenderStage     }   )   function update(log: number[]) {     log.shift()     log.push(shouldRender() ? 1 : 0)     return log   } </script> <Pane   title=\"Rendering Activity\"   position=\"fixed\" >   <WaveformMonitor     value={log}     min={-1}     max={2}   /> </Pane> Copy <script lang=\"ts\">   import { T } from '@threlte/core'   import { Grid, OrbitControls, interactivity } from '@threlte/extras'   import { spring } from 'svelte/motion'   interactivity()   const scale = spring(1) </script> <T.PerspectiveCamera   makeDefault   position={[10, 10, 10]}   on:create={({ ref }) => {     ref.lookAt(0, 0, 0)   }} >   <OrbitControls /> </T.PerspectiveCamera> <T.DirectionalLight   position={[3, 10, 7]}   intensity={Math.PI} /> <T.AmbientLight intensity={0.3} /> <T.Group   scale={$scale} on:pointerenter={() => scale.set(1.5)} on:pointerleave={() => scale.set(1)} > <T.Mesh position.y={1}> <T.SphereGeometry args={[1]} /> <T.MeshStandardMaterial color=\"#FE3D00\" toneMapped={false} /> </T.Mesh> </T.Group> <Grid cellColor=\"#FE3D00\" sectionColor=\"#FE3D00\" /> In the mode 'on-demand', Threlte renders the scene only when the current frame is invalidated. This may happen automatically when changes are detected or the frame is manually invalidated. This is the default mode and the recommended way of working with Threlte. Automatic Invalidation Threlte is able to automatically invalidate the current frame by observing component props and the mounting and unmounting of components. This means that when you e.g. change the position of a <T.Mesh> via component props, Threlte will automatically invalidate the current frame and request a new frame. Copy <script> import { T } from '@threlte/core' let x = 0 const move = () => { x += 1 } </script> <T.Mesh position.x={x} /> Manual Invalidation In some cases, you may want to manually invalidate the current frame because Threlte is not able to detect changes. To do this, you can use the invalidate function from the useThrelte hook. Copy <script> import { T, useThrelte } from '@threlte/core' import { Mesh } from 'three' const { invalidate } = useThrelte() const mesh = new Mesh() export const moveMesh = () => { // moving the mesh manually mesh.position.x = 1 // invalidate the current frame invalidate() } </script> <T is={mesh} /> useTask The useTask hook is by default configured to automatically invalidate the current frame on every frame. This means that you can use it to animate your scene without having to manually invalidate the current frame. Copy import { useTask } from '@threlte/core' useTask(() => { // useTask will automatically invalidate the current // frame, so you don't have to do it manually. }) Sometimes you may want to manually invalidate the current frame from within a task. To do this, you can use the invalidate function from the useThrelte hook and set the autoInvalidate option to false: Copy import { useTask, useThrelte } from '@threlte/core' const { invalidate } = useThrelte() useTask( () => { // Because `autoInvalidate` is set to `false`, the current // frame will not be invalidated automatically and you can // conditionally invalidate the current frame. invalidate() }, { autoInvalidate: false } ) Mode 'manual' In the manual mode, you must manually trigger a re-render: Copy const { advance } = useThrelte() advance() This mode is useful when you want to have full control over when the scene is rendered. For example, you may want to render the scene only when the user interacts with the scene. Mode 'always' In the 'always' mode, Threlte continuously renders the scene. This mode is the easiest to use, but it is also the most resource intensive and should only be used when necessary. Setting the Render Mode <Canvas> Prop You can set the render mode by setting the property renderMode on the <Canvas> component: Copy <Canvas renderMode=\"on-demand\" /> useThrelte Hook You can also set the render mode from anywhere within your Threlte app using the useThrelte hook: Copy const { renderMode } = useThrelte() renderMode.set('on-demand') The renderMode property can be changed at any time, but it will only take effect on the next frame. Render Modes and Custom Rendering By default, Threlte will automatically render the scene for you. In some cases, you may want to render the scene yourself, for example when using post processing. Set autoRender to false on the <Canvas> component. This will prevent Threlte from automatically rendering the scene and you can render the scene yourself. Copy <Canvas autoRender={false} /> Set up a task that renders the scene. There are two ways to do this: Add a task to Threlte’s default renderStage. Tasks in that stage will be executed after tasks in Threlte’s mainStage and only when a re-render is necessary based on the current render mode. This is the recommended approach. Copy import { useTask, useThrelte } from '@threlte/core' const { renderStage } = useThrelte() useTask( () => { // render here }, { stage: renderStage, autoInvalidate: false } ) Use shouldRender from the hook useThrelte. This function will evaluate to true based on the current render mode. This allows for more fine-grained control over when to render and is useful when you want to render in a task that is not in Threlte’s default renderStage. Copy import { useThrelte, useTask } from '@threlte/core' const { shouldRender } = useThrelte() useTask( () => { if (shouldRender()) { // render here } }, { autoInvalidate: false } ) Previous Page Loading Assets Next Page Disposing Objects On this page Mode 'on-demand' Automatic Invalidation Manual Invalidation useTask Mode 'manual' Mode 'always' Setting the Render Mode <Canvas> Prop useThrelte Hook Render Modes and Custom Rendering Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/learn/basics/disposing-objects","title":"Disposing Objects | Learn Threlte","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex Search Getting Started Introduction Installation Your First Scene Basics App Structure Scheduling Tasks Handling Events Loading Assets Render Modes Disposing Objects Advanced Plugins Custom Abstractions Migration Guides More Resources Basics Disposing Objects Freeing resources is a manual chore in three.js, but Svelte is aware of component lifecycles, hence Threlte will attempt to free resources for you by calling dispose, if present, on all unmounted objects and recursively on all properties that are not being used anywhere else in your scene. Automatic Disposal Copy <script> import { Mesh } from '@threlte/core' import { useTexture } from '@threlte/extras' const map = useTexture('/some/texture') </script> <!--  The geometry, material and the associated texture will  be disposed as soon as the <Mesh> component unmounts. --> <T.Mesh> <T.BoxGeometry /> <T.MeshStandardMaterial map={$map} /> </T.Mesh>  Be aware that calling dispose on a three.js buffer, material or geometry is merely deallocating it from the GPU memory. If an object is used after it’s disposed it will be allocated again, resulting in a performance drop for a single frame. It will not produce a runtime error.  Manual Disposal  You can switch off automatic disposal by placing dispose={false} onto components, it is now valid for the entire tree.  Copy <script>   import { Mesh, useTexture } from '@threlte/core'   import { BoxBufferGeometry, MeshStandardMaterial } from 'three'   const map = useTexture('/some/texture')   const material = new MeshStandardMaterial({ map }) </script> <!-- will not be disposed --> <T.Mesh dispose={false}>   <!-- will not be disposed -->   <T.BoxGeometry />   <!-- will not be disposed -->   <T.MeshStandardMaterial map={$map} /> <!-- will be disposed --> <T.Mesh dispose> <!-- will be disposed --> <T.BoxGeometry /> <!-- will be disposed --> <T.MeshStandardMaterial map={$map} />   </T.Mesh> </T.Mesh> Previous Page Render Modes Next Page Plugins On this page Automatic Disposal Manual Disposal Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/learn/getting-started/installation","title":"Installation | Learn Threlte","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  Getting Started Introduction Installation Your First Scene Basics App Structure Scheduling Tasks Handling Events Loading Assets Render Modes Disposing Objects Advanced Plugins Custom Abstractions Migration Guides More Resources Getting Started Installation  To start using Threlte, you can either scaffold a new project using the CLI or install the packages manually in an existing project.  Scaffold a new Threlte project  The easiest way to get started with Threlte is to use the command npm create threlte to scaffold a new project. This CLI will interactively guide you through creating a new SvelteKit project as well as installing and configuring Threlte and its dependencies.  Copy npm create threlte my-project Manually install Threlte in an existing project  Threlte consists of 7 packages which can be installed and used individually. @threlte/core and Three.js itself are required for all projects while the other packages are optional. @threlte/gltf does not need to be installed separately as it can be used with npx, the resulting Threlte components however require @threlte/extras to be installed.  Choose the packages you want to use @threlte/core  Compose Three.js scenes in a declarative and state-driven way. Three.js is required as a peer dependency.  @threlte/extras  Components, helpers, hooks and more that extend the core functionality.  @threlte/gltf  A command-line tool that turns GLTF assets into declarative and re-usable Threlte components. The generated Threlte components make use of the package @threlte/extras.  @threlte/rapier  Components and hooks to use the Rapier physics engine in Threlte.  @threlte/theatre  Components and hooks to use the animation library Theatre.js in Threlte.  @threlte/xr  Components and hooks for VR and AR.  @threlte/flex  Components and hooks to use the flex engine Yoga in Threlte.  @types/three  TypeScript types for Three.js.  Install the packages with npm, pnpm, yarn or any other package manager you prefer.  npm install three @threlte/core  Copy Configuration Adapt vite.config.js  If you are using Threlte with SvelteKit, adapt your Vite configuration to prevent three from being externalized for SSR by vites externalization step  vite.config.js Copy const config = {   // …   ssr: {     noExternal: ['three']   } } Adapt tsconfig.json  If you are using TypeScript, you need to add the following to your tsconfig.json to make sure that the types of the Threlte components are available:  tsconfig.json Copy {   \"compilerOptions\": {     \"moduleResolution\": \"Bundler\"   } }  See this comment for tips on how to reduce bundle size when working with bundlers like vite and three.js.  Previous Page Introduction Next Page Your First Scene On this page Scaffold a new Threlte project Manually install Threlte in an existing project Choose the packages you want to use Configuration Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/reference/rapier/getting-started","title":"Getting Started | @threlte/rapier","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  @threlte/rapier Getting Started COMPONENTS <World> <RigidBody> <Collider> <AutoColliders> <CollisionGroups> <Attractor> <Debug> HOOKS useRapier useCollisionGroups useRigidBody JOINTS About Joints useJoint useFixedJoint useRevoluteJoint useSphericalJoint usePrismaticJoint @threlte/rapier Getting Started  Rapier is a fast physics engine written in Rust. This package provides easy to use components and hooks to use the Rapier physics engine in Threlte.  To start off, it’s best to get yourself comfortable with the basic concepts of rapier.  This package is under heavy development and its API is subject to change. Also be aware that currently only one Rapier-enabled Threlte instance is possible.  Installation  Make sure to have @threlte/core installed.  Copy npm install @threlte/rapier @dimforge/rapier3d-compat Previous Page Getting Started Next Page Components On this page Installation Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/reference/gltf/getting-started","title":"Getting Started | @threlte/gltf","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  @threlte/gltf Getting Started @threlte/gltf Getting Started  A small command-line tool that turns GLTF assets into declarative and re-usable Threlte components.  The GLTF workflow on the web is not ideal. GLTF is thrown wholesale into the scene which prevents re-use, in threejs objects can only be mounted once Contents can only be found by traversal which is cumbersome and slow Changes to queried nodes are made by mutation, which alters the source data and prevents re-use Re-structuring content, making nodes conditional or adding/removing is cumbersome Model compression is complex and not easily achieved Models often have unnecessary nodes that cause extra work and matrix updates @threlte/gltf fixes that. It creates a virtual graph of all objects and materials. Now you can easily alter contents and re-use. The graph gets pruned (empty groups, unnecessary transforms, …) for better performance. It will optionally compress your model with up to 70%-90% size reduction. Usage Copy npx @threlte/gltf@latest /path/to/Model.glb [options] The CLI supports only npx at this moment. Options Option Description --output, -o Output file name/path --types, -t Add Typescript definitions --keepnames, -k Keep original names --meta, -m Include metadata (as userData) --shadows, -s Let meshes cast and receive shadows --printwidth, -w Prettier printWidth (default: 120) --precision, -p Number of fractional digits (default: 2) --draco, -d Draco binary path --preload -P Add preload method to module script --suspense -u Make the component suspense-ready --isolated, -i Output as isolated module (No $$restProps usage) --root, -r Sets directory from which .gltf file is served --transform, -T Transform the asset for the web (draco, prune, resize) --resolution, -R Transform resolution for texture resizing (default: 1024) --simplify, -S Transform simplification (default: false, experimental) --weld Weld tolerance (default: 0.0001) --ratio Simplifier ratio (default: 0.75) --error Simplifier error threshold (default: 0.001) --debug, -D Debug output Example This example assumes you have your model set up and exported from an application like Blender as a GLTF file. First you run your model through @threlte/gltf. npx allows you to use npm packages without installing them. Copy npx @threlte/gltf@latest model.gltf --transform This will create a Model.svelte file that plots out all of the assets contents. Copy <!-- Auto-generated by: https://github.com/pmndrs/gltfjsx Command: npx gltfjsx@0.0.1 ./stacy.glb --> <script> import { Group } from 'three' import { T } from '@threlte/core' import { useGltf, useGltfAnimations } from '@threlte/extras' export const ref = new Group() const gltf = useGltf('/stacy.glb') export const { actions, mixer } = useGltfAnimations(gltf, ref) </script> {#if $gltf}   <T     is={ref}     {...$$restProps}   >     <T.Group name=\"Scene\">       <T.Group         name=\"Stacy\"         rotation={[Math.PI / 2, 0, 0]}         scale={0.01}       >         <T is={$gltf.nodes.mixamorigHips} /> <T.SkinnedMesh name=\"stacy\" geometry={$gltf.nodes.stacy.geometry}           material={$gltf.nodes.stacy.material} skeleton={$gltf.nodes.stacy.skeleton}           rotation={[-Math.PI / 2, 0, 0]}           scale={100}         />       </T.Group>     </T.Group>     <slot {ref} />   </T> {/if}  Add your model to your /static folder as you would normally do. With the --transform flag it has created a compressed copy of it (in the above case model-transformed.glb). Without the flag just copy the original model.  Copy static/   model-transformed.glb  The component can now be dropped into your scene.  Copy <script>   import { Canvas } from '@threlte/core'   import Model from './Model.svelte' </script> <Canvas>   <Model /> </Canvas>  You can re-use it, it will re-use geometries and materials out of the box:  Copy <Model position={[0, 0, 0]} /> <Model position={[10, 0, -10]} />  Or make the model dynamic. Change its colors for example:  Copy <T.Mesh   geometry={$gltf.nodes.robot.geometry} material={$gltf.materials.metal}   material.color=\"green\" />  Or exchange materials:  Copy <T.Mesh geometry={$gltf.nodes.robot.geometry}> <T.MeshPhysicalMaterial color=\"hotpink\" /> </T.Mesh> Make contents conditional: Copy {#if condition} <T.Mesh geometry={$gltf.nodes.robot.geometry}     material={$gltf.materials.metal} /> {/if} DRACO Compression You don’t need to do anything if your models are draco compressed, since useGltf defaults to a draco CDN. By adding the --draco flag you can refer to local binaries which must reside in your /public folder. Auto-Transform With the --transform flag it creates a binary-packed, draco-compressed, texture-resized (1024x1024), webp compressed, deduped, instanced and pruned _.glb ready to be consumed on a web site. It uses glTF-Transform. This can reduce the size of an asset by 70%-90%. It will not alter the original but create a copy and append [modelname]-transformed.glb. Type-Safety Add the --types flag and your component will be typesafe. Copy <!-- Auto-generated by: https://github.com/pmndrs/gltfjsx Command: npx gltfjsx@0.0.1 ./stacy.glb -t --> <script lang=\"ts\"> import type _ as THREE from 'three' import { Group } from 'three' import { T, type Props, type Events, type Slots } from '@threlte/core' import { useGltf, useGltfAnimations } from '@threlte/extras' type $$Props = Props<THREE.Group>   type $$Events = Events<THREE.Group>   type $$Slots = Slots<THREE.Group>   export const ref = new Group()   type ActionName =     | 'pockets'     | 'rope'     | 'swingdance'     | 'jump'     | 'react'     | 'shrug'     | 'wave'     | 'golf'     | 'idle'   type GLTFResult = {     nodes: {       stacy: THREE.SkinnedMesh       mixamorigHips: THREE.Bone     }     materials: {}   }   const gltf = useGltf<GLTFResult>('/stacy.glb')   export const { actions, mixer } = useGltfAnimations<ActionName>(gltf, ref) </script> {#if $gltf}   <T     is={ref}     {...$$restProps} > <T.Group name=\"Scene\"> <T.Group name=\"Stacy\" rotation={[Math.PI / 2, 0, 0]} scale={0.01} > <T is={$gltf.nodes.mixamorigHips} /> <T.SkinnedMesh name=\"stacy\" geometry={$gltf.nodes.stacy.geometry}           material={$gltf.nodes.stacy.material} skeleton={$gltf.nodes.stacy.skeleton}           rotation={[-Math.PI / 2, 0, 0]}           scale={100}         />       </T.Group>     </T.Group>     <slot {ref} />   </T> {/if} Animations  If your GLTF contains animations it will add @threlte/extras’s useGltfAnimations hook, which extracts all clips and prepares them as actions:  Copy const gltf = useGltf('/stacy.glb') export const {(actions, mixer)} = useGltfAnimations(gltf, ref)  If you want to play an animation you can do so at any time:  Copy const onEvent = () => {   $actions.jump.play() } Suspense  If you want to use the component <Suspense> to suspend the rendering of loading components (and therefore models) and optionally show a fallback in a parent component component, you can do so by passing the flag --suspense to make the generated Threlte component suspense-ready:  Copy <script>   import Model from './Model.svelte'   import Fallback from './Fallback.svelte'   import { Suspense } from '@threlte/extras' </script> <Suspense>   <Fallback slot=\"fallback\" />   <Model /> </Suspense> Asset Pipeline  In larger projects with a lot of models and assets, it’s recommended to set up an asset pipeline with tools like npm-watch and Node.js scripts to automatically transform models to Threlte components and copy them to the right place as this makes iterating over models and assets much faster.  Previous Page transitions Next Page Getting Started On this page The GLTF workflow on the web is not ideal. @threlte/gltf fixes that. Usage Options Example DRACO Compression Auto-Transform Type-Safety Animations Suspense Asset Pipeline Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/learn/advanced/custom-abstractions","title":"Custom Abstractions | Learn Threlte","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  Getting Started Introduction Installation Your First Scene Basics App Structure Scheduling Tasks Handling Events Loading Assets Render Modes Disposing Objects Advanced Plugins Custom Abstractions Migration Guides More Resources Advanced Custom Abstractions  A lot of the components you will find in the package @threlte/extras are abstractions on top of the <T> component. These abstractions provide extra functionality like automatically invalidating the frame or providing default values or extra props.  A common use case for custom abstractions is to create a component that is a fixed entity in your Threlte app which you want to reuse in multiple places. As an example, let’s create a component that is made up from multiple <T> components resembling a floor and a cube on top:  Tile.svelte Copy <script>   import { T } from '@threlte/threlte'   import { DEG2RAD } from 'three/src/math/MathUtils' </script> <T.Group>   <!-- 1x1x1 Cube -->   <T.Mesh     position.y={0.5}   >     <T.BoxGeometry />     <T.MeshStandardMaterial />   </T.Mesh>   <!-- 2x2 Floor -->   <T.Mesh     rotation.x={-90 * DEG2RAD}   >     <T.PlaneGeometry args={[2, 2]} />     <T.MeshStandardMaterial />   </T.Mesh>   <!-- A slot to nest objects in -->   <slot /> </T.Group>  Let’s see what implementing that component looks like:  Scene.svelte Copy <script>   import Tile from './Tile.svelte' </script> <Tile /> Props  The <Tile> component is now available in the scene and can be reused as many times as you want. Now we’d like to assign a different position to the <Tile> component in order to move it around. We can do that by passing a position prop to the <Tile> component:  Scene.svelte Copy <script>   import Tile from './Tile.svelte' </script> <Tile position={[0, 0, 0]} /> <Tile position={[2, 0, 0]} /> <Tile position={[4, 0, 0]} />  The component <Tile> internally needs to use the position prop in order to set the position of the <T> components. We can do that by spreading $$restProps on the <T.Group> component at the root hierarchy of <Tile>: Tile.svelte Copy <script> import { T } from '@threlte/threlte' import { DEG2RAD } from 'three/src/math/MathUtils' </script> <T.Group {...$$restProps}>   <!-- 1x1x1 Cube -->   <T.Mesh     position.y={0.5}   >     <T.BoxGeometry />     <T.MeshStandardMaterial />   </T.Mesh>   <!-- 2x2 Floor -->   <T.Mesh rotation.x={-90 * DEG2RAD}>     <T.PlaneGeometry args={[2, 2]} />     <T.MeshStandardMaterial />   </T.Mesh>   <!-- A slot to nest objects in -->   <slot /> </T.Group> Events  The following section assumes you use the plugin interactivity to listen to pointer events.  We successfully forwarded all props and are able to move the <Tile> component around in the scene. However, we may also need to listen to events on objects inside <Tile>. Threlte provides the utility function forwardEventHandlers to forward event handlers defined on <Tile> internally to our cubes <T.Mesh> component.  Tile.svelte Copy <script>   import { T, forwardEventHandlers } from '@threlte/threlte'   import { DEG2RAD } from 'three/src/math/MathUtils'   const component = forwardEventHandlers() </script> <T.Group {...$$restProps}> <!-- 1x1x1 Cube --> <T.Mesh position.y={0.5} bind:this={$component}   >     <T.BoxGeometry />     <T.MeshStandardMaterial />   </T.Mesh>   <!-- 2x2 Floor -->   <T.Mesh rotation.x={-90 * DEG2RAD}>     <T.PlaneGeometry args={[2, 2]} />     <T.MeshStandardMaterial />   </T.Mesh>   <!-- A slot to nest objects in -->   <slot /> </T.Group>  When we now add an on:click event handler to the <Tile> component, we can see that the event handler is called when we click on the floor:  Scene.svelte Copy <script>   import Tile from './Tile.svelte' </script> <Tile   on:click={() => {     console.log('clicked')   }} /> Types The following section assumes you use TypeScript.  The last thing we need to do is to add types to our custom abstraction so that editors like VSCode can provide us with autocompletion and type checking. We will create a Tile.d.ts file next to the Tile.svelte file and add the following content:  Tile.d.ts Copy import type { Events, Props, Slots } from '@threlte/core' import { SvelteComponentTyped } from 'svelte' import type { Group } from 'three' export type TileProps = Props<Group> & {   // Define extra props here. } export type TileEvents = Events<Mesh> & {   // Define extra events here. } export type TileSlots = Slots<Mesh> & {   // Define extra slots here. } export default class Tile extends SvelteComponentTyped<TileProps, TileEvents, TileSlots> {}  Now we can use the <Tile> component in our scene and get autocompletion and type checking:  Scene.svelte Copy <script>   import Tile from './Tile.svelte' </script> <!-- Autocompletion and type checking works here. --> <Tile position={[0, 0, 0]} />  Let’s cross check the types inside our Tile.svelte file by implementing $$Props, $$Events and $$Slots. We immediately see that we forgot to pass the slot prop ref to our <slot />, let’s add that:  Tile.svelte Copy <script lang=\"ts\">   import { T, forwardEventHandlers } from '@threlte/threlte'   import { DEG2RAD } from 'three/src/math/MathUtils'   import type { TileProps, TileEvents, TileSlots } from './Tile.svelte'   type $$Props = TileProps   type $$Events = TileEvents   type $$Slots = TileSlots   const component = forwardEventHandlers() </script> <T.Group {...$$restProps} let:ref> <!-- 1x1x1 Cube --> <T.Mesh position.y={0.5} bind:this={$component}   >     <T.BoxGeometry />     <T.MeshStandardMaterial />   </T.Mesh>   <!-- 2x2 Floor -->   <T.Mesh rotation.x={-90 * DEG2RAD}>     <T.PlaneGeometry args={[2, 2]} />     <T.MeshStandardMaterial />   </T.Mesh>   <!-- A slot to nest objects in -->   <slot {ref} /> </T.Group> Previous Page Plugins Next Page Migration Guides On this page Props Events Types Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/learn/basics/app-structure","title":"App Structure | Learn Threlte","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  Getting Started Introduction Installation Your First Scene Basics App Structure Scheduling Tasks Handling Events Loading Assets Render Modes Disposing Objects Advanced Plugins Custom Abstractions Migration Guides More Resources Basics App Structure  Threlte makes heavy use of Svelte’s Context API as a way to pass data through the component tree without having to pass props down manually at every level:  SomeComponent.svelte Copy <script>   const { camera, renderer } = useThrelte() </script>  To let Threlte do its magic, we recommend to follow our best practices for structuring your app.  Recommended App Structure  The <Canvas> component provides all basic contexts in a Threlte application. The recommended app structure is to have a single child component of <Canvas> (typically named “Scene.svelte” in examples) for your Threlte app. This will allow contexts provided by useThrelte and other hooks to be used.  App.svelte Copy <script>   import { Canvas } from '@threlte/core'   import Scene from './Scene.svelte' </script> <Canvas>   <Scene /> </Canvas> Scene.svelte Copy <script>   import { T, useTask } from '@threlte/core'   import { interactivity } from '@threlte/extras'   import Player from './Player.svelte'   import World from './World.svelte'   let rotation = 0   // useTask is relying on a context provided   // by <Canvas>. Because we are definitely *inside*   // <Canvas>, we can safely use it.   useTask((delta) => {     rotation += delta   })   // This file is also typically the place to   // inject plugins   interactivity() </script> <T.Mesh rotation.y={rotation}>   <T.BoxGeometry />   <T.MeshBasicMaterial color=\"red\" /> </T.Mesh> <Player /> <World /> Context Not Available  The following app structure is deceiving. It looks like it should work, but it will not. The problem is that the useTask hook is called outside of the <Canvas> component, so the main Threlte context is not available. Usually hooks relying on some context will tell you with descriptive error messages when they are used outside of their context.  App.svelte Copy <script>   import { Canvas, useTask, T } from '@threlte/core'   let rotation = 0   // This won't work, we're not inside <Canvas>   useTask((delta) => {     rotation += delta   }) </script> <Canvas>   <T.Mesh rotation.y={rotation} /> </Canvas> Previous Page Your First Scene Next Page Scheduling Tasks On this page Recommended App Structure Context Not Available Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/learn/basics/loading-assets","title":"Loading Assets | Learn Threlte","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  Getting Started Introduction Installation Your First Scene Basics App Structure Scheduling Tasks Handling Events Loading Assets Render Modes Disposing Objects Advanced Plugins Custom Abstractions Migration Guides More Resources Basics Loading Assets  A typical Threlte application will make use of textures, models, and other assets. These assets are loaded using the useLoader hook. Assets loaded via useLoader are automatically cached and will not be loaded or parsed again if they are already in the cache.  This section assumes you placed your assets in your public folder or in a place in your application where you can import them easily.  Loading Models  Models of different 3D model extensions can be loaded with their respective loaders. For this guide, we’re going to use the GLTFLoader to load a .gltf model. In this section we’re also going to discuss a few things that are specific to loading and caching models.  We start off by importing the GLTFLoader and useLoader hook:  Copy import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader' import { useLoader } from '@threlte/core'  Then we can use the useLoader hook to load our model:  Copy const gltf = useLoader(GLTFLoader).load('/assets/model.gltf')  Again, the type of gltf is an AsyncWritable custom store. Its value will be undefined until the model has loaded. To use this model, we can use a conditional:  Copy {#if $gltf}   <T is={$gltf.scene} /> {/if} Reusing Models We included the <T> component here to add the model to our Threlte application but immediately two problems arise: The contents of the model are opaque to us. At the code level we don’t know what the model contains and we can’t access it. The model is cached. If we load the same model again, we won’t get a new model but the same model we already loaded and we can’t place it in our scene again at a different location. To fix this, we’ll use Threlte’s CLI tool @threlte/gltf to generate a reusable Svelte component from our model. Run npx @threlte/gltf@latest /path/to/model.gltf to generate a Svelte component from your model. This will generate a file called Model.svelte in the same directory as your model. This is how a generated component looks like: Copy <!-- Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf Command: npx @threlte/gltf@0.0.5 Flower.glb --> <script> import { Group } from 'three' import { T } from '@threlte/core' import { useGltf } from '@threlte/extras' export const ref = new Group() const gltf = useGltf('/Flower.glb') </script> {#if $gltf}   <T     is={ref}     {...$$restProps}   >     <T.Mesh       geometry={$gltf.nodes.Blossom.geometry} material={$gltf.materials.Blossom}       rotation={[Math.PI / 2, 0, 0]}       scale={1.22}     />     <T.Mesh       geometry={$gltf.nodes.Stem.geometry} material={$gltf.materials.Stem}       rotation={[Math.PI / 2, 0, 0]}       scale={1.22}     />     <slot {ref} />   </T> {/if}  The generated component will still use the cache and will only reinstaniate parts of the model that make it reusable. This practice reduces network requests, bandwidth, memory usage and improves the performance of your Threlte application.  You can then import this component and use it in your application:  Copy <script>   import Model from './Model.svelte' </script> <!-- Use props to transform your model --> <Model   position.x={2}   scale={2} /> <!-- Reuse it across your application --> <Model   position.x={10}   scale={1.5}   rotation.y={Math.PI / 2} /> <!-- Nest other components in it --> <Model   position.x={10}   scale={1.5}   rotation.y={Math.PI / 2} >   <!-- <OtherModel /> --> </Model> Convenient: useGltf  @threlte/extras provides a handy hook for loading one-off .gltf models called useGltf:  Copy <script>   import { useGltf } from '@threlte/extras' </script> {#await useGltf('/assets/model.gltf') then gltf}   <T is={gltf.scene} /> {/await} Model Is Cached  Keep in mind that this hook caches the result and therefore is most suitable for loading models that are placed in the scene only once.  Loading Textures  To start off, we import the TextureLoader from three and the useLoader hook from @threlte/core:  Copy import { TextureLoader } from 'three' import { useLoader } from '@threlte/core'  Then we can use the useLoader hook to load our texture:  Copy const texture = useLoader(TextureLoader).load('/assets/texture.png')  The type of texture is a custom store that Threlte provides called AsyncWritable. It’s very much like a regular Svelte store but with a few extra features. Its value will be undefined until the texture has loaded. Once the texture has loaded, the value will be the loaded texture. To use this texture on a material, we can use a conditional:  Copy {#if $texture}   <T.MeshStandardMaterial map={$texture} /> {/if} Since the underlying promise properties then and catch are exposed on the store itself, we can also make use of that and await the texture to be loaded: Copy <!-- Here, \"texture\" is acting like a regular promise --> {#await texture then value} <T.MeshStandardMaterial map={value} /> {/await} Loading multiple textures Some materials are composed of multiple textures for different material channels. useLoader provides a way to load multiple textures at once and spread the loaded textures on a material. Let’s say we want to load a texture for the map and normalMap channels: Copy const textures = useLoader(TextureLoader).load({ map: '/assets/texture.png', normalMap: '/assets/normal.png' }) We can then spread the textures on a material via Svelte’s spread syntax: Copy {#if $textures}   <T.MeshStandardMaterial {...$textures} /> {/if} Keep in mind that the promise only resolves and the store gets populated once all textures have loaded. Applying different textures to different faces For example, we may want to apply different textures to different faces of a BoxGeometry instance. To apply each texture to the corresponding face we can pass a function to the attach prop: Copy <T.Mesh> <T.BoxGeometry /> <T.MeshStandardMaterial map={texture1} attach={(parent, self) => { if (Array.isArray(parent.material)) parent.material = [...parent.material, self] else parent.material = [self] }} /> <T.MeshStandardMaterial map={texture2} attach={(parent, self) => { if (Array.isArray(parent.material)) parent.material = [...parent.material, self] else parent.material = [self] }} /> </T> Convenient: useTexture @threlte/extras provides a handy hook for loading textures called useTexture: Copy <script> import { useTexture } from '@threlte/extras' </script> {#await useTexture('/assets/texture.png') then texture} <T.MeshStandardMaterial map={texture} /> {/await} Context Awareness The hooks useLoader, useTexture and useGltf are context aware. This means that they will automatically use the context of a parent <Canvas> component to make sure assets are only cached in the context of the current Threlte app. You can’t use them outside of a <Canvas> component, in a component that is not a child of a <Canvas> component, or outside of component initialization. If you know how to use Svelte’s onMount hook then you know how to use useLoader and useTexture. To load assets outside of a components initialization you can separate instantiating the loader from loading the asset all while making use of asset caching: Copy <script> import { AudioLoader } from 'three' import { useLoader } from '@threlte/core' // Instantiate the loader at component initialization const loader = useLoader(AudioLoader) const onSomeEvent = async () => { // Load the asset when needed const audioBuffer = await loader.load('/assets/sound.mp3') } </script> Previous Page Handling Events Next Page Render Modes On this page Loading Models Reusing Models Convenient: useGltf Loading Textures Loading multiple textures Applying different textures to different faces Convenient: useTexture Context Awareness Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/learn/getting-started/your-first-scene","title":"Your First Scene | Learn Threlte","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex Search Getting Started Introduction Installation Your First Scene Basics App Structure Scheduling Tasks Handling Events Loading Assets Render Modes Disposing Objects Advanced Plugins Custom Abstractions Migration Guides More Resources Getting Started Your First Scene You should be versed in both Svelte and Three.js before rushing into Threlte. If you are unsure about Svelte, consult its Tutorial for a quick introduction. As for Threejs, make sure you at least glance over its official documentation. Structuring Your App As a first step we’re creating a new Svelte file called App.svelte where we are importing the <Canvas> component. App.svelte Copy <script> import { Canvas } from '@threlte/core' import Scene from './Scene.svelte' </script> <Canvas> <Scene /> </Canvas> The <Canvas> component is the root component of your Threlte application. It creates a renderer and sets up some sensible defaults for you like antialiasing and color management. It also creates a default camera and provides the context in which your Threlte application will run. For improving access to this runtime context, it’s best practice to create a seperate component called Scene.svelte and including it in our App.svelte file. Creating Objects At this point we’re looking at a blank screen. Let’s add a simple cube to it. In Scene.svelte, we’re importing the <T> component which is the main building block of your Threlte application. It’s a generic component that we use to render any Three.js object. In this case we’re creating a THREE.Mesh which is made up from a THREE.BoxGeometry and a THREE.MeshBasicMaterial. We should now be looking at a white cube on a transparent background. Scene.svelte Copy <script> import { T } from '@threlte/core' </script> <T.Mesh> <T.BoxGeometry /> <T.MeshBasicMaterial /> </T.Mesh> attach Behind the scenes we’re using the property attach available on <T> to attach an object to a property of its parent. Binding geometries to the property geometry and materials to the property material is a common pattern so Threlte takes care of it for you. Learn more Three.js equivalent Modifying Objects That cube is still a bit boring. Let’s add some color to it, and make it a bit bigger! We also want to move it up a little to highlight it. We can do this by passing props to the <T> component. Scene.svelte Copy <script> import { T } from '@threlte/core' </script> <T.Mesh position.y={1}> <T.BoxGeometry args={[1, 2, 1]} /> <T.MeshBasicMaterial color=\"hotpink\" /> </T.Mesh> Threlte automatically generates props for <T> based on the underlying Three.js object. This means you can easily guess most <T> props based on the Three.js docs for the class you are using. Three.js equivalent The special args prop we use in <T.BoxGeometry> corresponds to the object’s constructor arguments. Props interpreted from the underlying Three.js object are called auto props, like color in our <T.MeshBasicMaterial>. Leveraging Threlte’s Pierced Props you can directly assigned to attributes of props like position.y in our <T.Mesh>. Learn more Primitive Values From a performance perspective, it’s often better to use pierced props because primitive prop values can safely be compared for equality. This means that if the value of a prop doesn’t change, Threlte will skip any updates to the underlying Three.js object. Constant prop types The type of an inferred prop (or “auto prop”) must be constant. This means that the type of a prop must not change for the lifetime of the component. For instance you can’t use a variable as a prop that is an array of numbers and then later on change the value of that variable to a single number. This is considered a type change and therefore not allowed. Pointing the Camera We’re still staring at the side of a cube, let’s add a camera and offset it from the center: Scene.svelte Copy <script> import { T } from '@threlte/core' </script> <T.PerspectiveCamera makeDefault position={[10, 10, 10]} on:create={({ ref }) => { ref.lookAt(0, 1, 0) }} /> <T.Mesh position.y={1}> <T.BoxGeometry args={[1, 2, 1]} /> <T.MeshBasicMaterial color=\"hotpink\" /> </T.Mesh> We’re again using the <T> component to create a THREE.PerspectiveCamera. We’re also passing a makeDefault prop which will make this camera the default camera of our application. The renderer now uses this camera to render our scene. Events Threlte supports listening to certain events on <T/> components. Here, we use the create event to get a reference to the underlying Three.js object as soon as it’s created and use the method lookAt to look at the cube. Enabling Interactivity Let’s say we want to scale our cube as soon as we hover over it. We first have to import the plugin interactivity from @threlte/extras and invoke it in our Scene.svelte file; We can now add interaction event listeners to our <T> components. We will add pointerenter and pointerleave event listeners to our cube. In the event handlers we’ll update the value of a Svelte spring store and apply the stores value to the property scale of the component <T.Mesh>. Scene.svelte Copy <script> import { T } from '@threlte/core' import { interactivity } from '@threlte/extras' import { spring } from 'svelte/motion' interactivity() const scale = spring(1) </script> <T.PerspectiveCamera makeDefault position={[10, 10, 10]} on:create={({ ref }) => { ref.lookAt(0, 1, 0) }} /> <T.Mesh position.y={1} scale={$scale}   on:pointerenter={() => scale.set(1.5)}   on:pointerleave={() => scale.set(1)} >   <T.BoxGeometry args={[1, 2, 1]} />   <T.MeshBasicMaterial color=\"hotpink\" /> </T.Mesh> Automatic Vector & Scalar Detection  You might have noticed that we’re only passing a single number to the prop scale on <T.Mesh>. Threlte automatically figures out whether you are passing an array or a number and uses the appropriate underlying Three.js method.  Learn more  Realtime Variables  When working with realtime apps where variables e.g. position and rotation change constantly, an easy way observe the values is with live expressions.  Adding Animation  Let’s add some motion to our cube. We will use Threlte’s useTask hook to tap into Threlte’s unified frame loop and run a function on every frame. We again use a Pierced Prop to let the cube rotate around its y-axis.  Scene.svelte Copy <script>   import { T, useTask } from '@threlte/core'   import { interactivity } from '@threlte/extras'   import { spring } from 'svelte/motion'   interactivity()   const scale = spring(1)   let rotation = 0   useTask((delta) => {     rotation += delta   }) </script> <T.PerspectiveCamera   makeDefault   position={[10, 10, 10]}   on:create={({ ref }) => {     ref.lookAt(0, 1, 0)   }} /> <T.Mesh   rotation.y={rotation}   position.y={1}   scale={$scale} on:pointerenter={() => scale.set(1.5)} on:pointerleave={() => scale.set(1)} > <T.BoxGeometry args={[1, 2, 1]} /> <T.MeshBasicMaterial color=\"hotpink\" /> </T.Mesh> useTask registers a callback that will be invoked on every frame. The callback receives the time delta since the last frame as an argument. We use the delta to update the rotation independent of the frame rate – the cube will rotate at the same speed regardless of the frame rate. Adjusting the Lighting We’re almost done. Let’s add some shading to our cube and a light source. We’ll use a THREE.MeshStandardMaterial on our cube and a THREE.DirectionalLight to illuminate our scene. Scene.svelte Copy <script> import { T, useTask } from '@threlte/core' import { interactivity } from '@threlte/extras' import { spring } from 'svelte/motion' interactivity() const scale = spring(1) let rotation = 0 useTask((delta) => { rotation += delta }) </script> <T.PerspectiveCamera makeDefault position={[10, 10, 10]} on:create={({ ref }) => { ref.lookAt(0, 1, 0) }} /> <T.DirectionalLight position={[0, 10, 10]} /> <T.Mesh rotation.y={rotation} position.y={1} scale={$scale}   on:pointerenter={() => scale.set(1.5)}   on:pointerleave={() => scale.set(1)} >   <T.BoxGeometry args={[1, 2, 1]} />   <T.MeshStandardMaterial color=\"hotpink\" /> </T.Mesh> Casting Shadows  We would like our cube to cast a shadow. To do so, we need a floor for it to cast a shadow on, so we add a new <T.Mesh> but this time with <T.CircleGeometry>. To enable shadows, we need to set castShadow on both the light and our cube, and set receiveShadow on our new floor:  Scene.svelte Copy <script>   import { T, useTask } from '@threlte/core'   import { interactivity } from '@threlte/extras'   import { spring } from 'svelte/motion'   interactivity()   const scale = spring(1)   let rotation = 0   useTask((delta) => {     rotation += delta   }) </script> <T.PerspectiveCamera   makeDefault   position={[10, 10, 10]}   on:create={({ ref }) => {     ref.lookAt(0, 1, 0)   }} /> <T.DirectionalLight   position={[0, 10, 10]}   castShadow /> <T.Mesh   rotation.y={rotation}   position.y={1}   scale={$scale} on:pointerenter={() => scale.set(1.5)} on:pointerleave={() => scale.set(1)} castShadow > <T.BoxGeometry args={[1, 2, 1]} /> <T.MeshStandardMaterial color=\"hotpink\" /> </T.Mesh> <T.Mesh rotation.x={-Math.PI / 2} receiveShadow > <T.CircleGeometry args={[4, 40]} /> <T.MeshStandardMaterial color=\"white\" /> </T.Mesh> Conclusion Congratulations, you’ve just created your first Three.js scene with Threlte! It includes important Three.js and Threlte concepts and should give you a good starting point for your first Threlte project. Previous Page Installation Next Page App Structure On this page Structuring Your App Creating Objects Modifying Objects Pointing the Camera Enabling Interactivity Adding Animation Adjusting the Lighting Casting Shadows Conclusion Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/learn/advanced/migration-guides","title":"Migration Guides | Learn Threlte","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex Search Getting Started Introduction Installation Your First Scene Basics App Structure Scheduling Tasks Handling Events Loading Assets Render Modes Disposing Objects Advanced Plugins Custom Abstractions Migration Guides More Resources Advanced Migration Guides Threlte 7 Threlte 7 introduces a new Task Scheduling System that allows you to easily orchestrate the task execution order of your Threlte application. For details on how to use it, see the documentation. Before, you had the option to choose between useFrame and useRender to orchestrate your rendering pipeline. These hooks are currently still available but will be removed in the next major version of Threlte. This guide will help you migrate your application to the new Task Scheduling System. This update also slightly changes the signature of the <Canvas> component as well as the Threlte context. Also, to increase performance we’re enforcing the use of constant prop types on the <T> component. Constant prop types on <T> The <T> component now enforces the use of constant prop types. This means that the type of a certain prop value must not change in the lifetime of a component. See this example: Threlte 6 Copy <script> import { T } from '@threlte/core' let position = [0, 0, 0] const changePosition = () => { position = 1 } </script> <T.Mesh {position} /> When changePosition is invoked, the prop type of the prop position changes from an array of numbers to a number. This is not allowed anymore in Threlte 7. Prop types must be constant. It’s a highly unlikely scenario that rarely occurs and a rather bad practice to start with, which allows us to optimize the performance of the <T> component by enforcing this rule. This is how you would migrate the above example: Threlte 7 Copy <script> import { T } from '@threlte/core' let position = [0, 0, 0] const changePosition = () => { position = [1, 1, 1] } </script> <T.Mesh {position} /> Threlte context <Canvas> props frameloop frameloop is now called renderMode as it only affects the rendering of your Threlte application. It accepts nearly the same values as before: Threlte 6 Copy <Canvas frameloop=\"always\" /> <Canvas frameloop=\"demand\" /> <Canvas frameloop=\"never\" /> Threlte 7 Copy <Canvas renderMode=\"always\" /> <Canvas renderMode=\"on-demand\" /> <Canvas renderMode=\"manual\" /> If the value is always, Threlte will render your scene on every frame. If the value is on-demand, Threlte will only render your scene when a re-render is needed. If the value is manual, Threlte will never render your scene automatically and you have to trigger a re-render by calling advance() on the Threlte context available via useThrelte(). autoRender When autoRender is false, Threlte will not render your scene automatically and will enable you to implement a custom render pipeline using the hook useTask. If adding a task to render the scene to Threlte’s renderStage, the task will only be called in respect to the renderMode prop. Previously, this behavior was inferred from the usage of the useRender hook, but we think being explicit here is better. useFrame The hook useTask replaces useFrame. It has a slightly different signature and allows you to to add a task to Threlte’s Task Scheduling System. A task may have dependencies to other tasks, which you can think of as the big brother of the order option of useFrame. Callback Arguments The callback to useTask now only receives the delta time since the last frame. The Threlte context previously available as the first argument to the callback of useFrame should be retrieved using the hook useThrelte. Threlte 6 Copy useFrame(({ camera, scene }, delta) => { // The Threlte context was previously available as the first // argument to the callback, followed by the delta time since the // last frame. }) Threlte 7 Copy const { camera, scene } = useThrelte() useTask((delta) => { // The delta time since the last frame is the only // argument to the callback. }) autostart and invalidate The options of useTask have been renamed to better reflect their purpose. The autostart option is now called autoStart (note the capital ‘S’), invalidate is now called autoInvalidate. If you didn’t use the order option Replace useFrame with useTask and adapt accessing the Threlte context. Threlte 6 Copy useFrame(({ camera, scene }, delta) => { // ... }) Threlte 7 Copy const { camera, scene } = useThrelte() useTask((delta) => { // ... }) If you used the order option Migrate to useTask by referencing the key of the task you want to depend on. Threlte 6 Copy useFrame((_, delta) => { // This task will be executed first }, { order: 0 }) useFrame((_, delta) => { // This task will be executed second }, { order: 1 }) Threlte 7 Copy useTask('first', (delta) => { // ... }) useTask('second', (delta) => { // This task will be executed after the task with the // key 'first' has been executed. }, { after: 'first' }) useRender The hook useTask also replaces useRender. Previously, useRender allowed you to define a callback that was invoked after all useFrame callbacks have been invoked to render your scene with a custom render pipeline. This is now possible with useTask as well. Threlte provides a renderStage that only ever executes its tasks when a re-render is needed. A task added to this stage can be used to render your scene. Be sure to set the option autoInvalidate to false to prevent Threlte from automatically invalidating the render stage. Threlte 6 Copy useRender(() => { // Render your scene here }) Threlte 7 Copy const { renderStage } = useThrelte() useTask('render', () => { // Render your scene here }, { stage: renderStage, autoInvalidate: false }) Callback Arguments The callback to useTask now only receives the delta time since the last frame. The Threlte context previously available as the first argument to the callback of useRender should be retrieved using the hook useThrelte. Threlte 6 Copy useRender(({ camera, scene }, delta) => { // The Threlte context was previously available as the first // argument to the callback, followed by the delta time since the // last frame. }) Threlte 7 Copy const { camera, scene } = useThrelte() useTask((delta) => { // The delta time since the last frame is the only // argument to the callback. }) If you didn’t use the order option Replace useFrame with useTask and adapt accessing the Threlte context. Threlte 6 Copy useRender((_{ camera, scene }_, delta) => { // ... }) Threlte 7 Copy const { renderStage } = useThrelte() useTask((delta) => { // ... }, { stage: renderStage, autoInvalidate: false }) If you used the order option Migrate to useTask by referencing the key of the task you want to depend on. Threlte 6 Copy useRender((_, delta) => { // This task will be executed first }, { order: 0 }) useRender((_, delta) => { // This task will be executed second }, { order: 1 }) Threlte 7 Copy const { renderStage } = useThrelte() useTask('first', (delta) => { // ... }, { stage: renderStage, autoInvalidate: false }) useTask('second', (delta) => { // This task will be executed after the task with the // key 'first' has been executed. }, { after: 'first', stage: renderStage, autoInvalidate: false }) Migrating from Threlte 5 to Threlte 6 Threlte 6 provides a much more mature and feature-rich API and developer experience than its predecessor at the cost of a lot of breaking changes. This guide will help you migrate your Threlte 5 project to Threlte v6. Preprocessing Preprocessing is not needed anymore starting from Threlte 6. This means you may remove the preprocessor @threlte/preprocess from your project as well as its configuration in svelte.config.js. You can now use the component <T> directly. <Three> is now <T> Threlte 6 merges the <Three> and <T> components into a single component. The property type was renamed to is to also properly reflect the fact that it can be used with already instantiated objects. @threlte/core is only about the <T> component The @threlte/core package is now only about the <T> component. It does not provide any abstractions that have been part of the core package before. Some of these abstractions (<TransformControls>, <OrbitControls>, audio components and several hooks) have been moved to @threlte/extras as this is the new home for commonly used abstractions. Prop types Threlte 6 heavily relies on prop types that Three.js naturally understands. As such, the prop types you may have previously used to define for example the position of an object changed. Threlte v5 provided its own prop types Position (e.g. { x, y, z }), Rotation and others which are now removed or deprecated. While not yet all abstractions fully make use of the new prop types, we’re working on it. Your editor should be able to provide you with the correct prop types for the components you’re using. Interactivity Interactivity is now handled by a plugin that’s available at @threlte/extras. It’s much more mature and flexible in terms of event handling. For instance – as some of you requested – you may now define on what object the main event listener is placed. Check out its documentation to learn more. useLoader now returns a store The hook useLoader now returns a custom Svelte store called AsyncWritable. This store allows you to await the loading of the resource while also implementing a regular Svelte store. It also now caches the results of the loader function so that it’s not called multiple times for the same resource. You will most likely benefit from quite a performance boost in applications that rely heavily on external resources. useThrelteRoot has been removed The hook useThrelteRoot has been removed and its properties have partially been merged into useThrelte as well as a new internal context which is not exposed. All other contexts (which were used internally) have also been merged or removed. <Pass> and the default effects rendering are removed In the effort of clear separation of concerns, the component <Pass> as well as the rendering with Three.js default EffectComposer have been removed. Threlte 6 now provides a hook called useRender which allows you to easily set up sophisticated rendering pipelines. As soon as a useRender hook is implemented, Threlte’s default render pipeline is disabled. useRender callbacks will be invoked after all callback to useFrame have been invoked. This means that you can use useFrame to update your objects and useRender to render it. useRender also has the option of ordering callbacks to orchestrate the rendering pipeline across multiple components. Threlte’s main context types Thelte’s main context contains Svelte stores. These stores are now a custom Threlte store called CurrentWritable which is a store that contains a current value with a reference to the current value of the store. This means it does not need to be unwrapped manually (and expensively!) in non-reactive places such as loops. For instance, let’s have a look at its usage in the hook useFrame where the context is available as the first argument to the callback: Copy useFrame(({ camera, colorSpace }) => { // instead of get(camera) we now can … camera.current // THREE.Camera colorSpace.current // THREE.ColorSpace }) The full type definition is currently listed here. useGltfAnimations Signature The signature of the hook useGltfAnimations has changed. It no longer provides a callback that is invoked when the gltf store has been populated and the actions store has been set. This is because it with the option to set a custom root for the THREE.AnimationAction, the callback could be triggered multiple times, leading to an unpredictable behavior. You should reside to using the actions store returned from the hook instead. Copy const { actions } = useGltfAnimations(gltf) // this animation will play when the gltf store has been populated // and the actions store has been set, effectively replacing the // callback. $: $actions.Greet?.play()  Check out the hooks documentation for more information.  @threlte/rapier Transform props  In an effort to clearly separate concerns, the components <Collider>, <AutoColliders> and <RigidBody> no longer offer transform props (position, rotation, scale and lookAt). Instead, you should wrap these components in for instance <T.Group> components and apply transforms on these.  Before.svelte Copy <Collider   position={[0, 1, 0]}   rotation={[0, 45 * DEG2RAD, 0]} >   <T.Mesh>     <T.BoxBufferGeometry />     <T.MeshStandardMaterial />   </T.Mesh> </Collider> After.svelte Copy <T.Group   position={[0, 1, 0]}   rotation={[0, 45 * DEG2RAD, 0]} >   <Collider>     <T.Mesh>       <T.BoxBufferGeometry />       <T.MeshStandardMaterial />     </T.Mesh>   </Collider> </T.Group> Previous Page Custom Abstractions Next Page Resources On this page Threlte 7 Constant prop types on <T> Threlte context <Canvas> props useFrame useRender Migrating from Threlte 5 to Threlte 6 Preprocessing <Three> is now <T> @threlte/core is only about the <T> component Prop types Interactivity useLoader now returns a store useThrelteRoot has been removed <Pass> and the default effects rendering are removed Threlte’s main context types useGltfAnimations Signature @threlte/rapier Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/learn/basics/handling-events","title":"Handling Events | Learn Threlte","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  Getting Started Introduction Installation Your First Scene Basics App Structure Scheduling Tasks Handling Events Loading Assets Render Modes Disposing Objects Advanced Plugins Custom Abstractions Migration Guides More Resources Basics Handling Events  Events are a way to listen for changes in the state of the application. Listening to events is as easy as adding a regular Svelte event listener to <T> components: <T.Mesh on:click={onClick}>. Threlte supports wheel, click and pointer events through the plugin interactivity from '@threlte/extras' as well as the create event and arbitrary three.js object events on objects that extend THREE.EventDispatcher (like OrbitControls). Click, pointer and wheel events contain the native browser event as well as the raycast event data (object, point, distance and other data).  Create Event  The create event is triggered when the underlying three.js object is created in a <T> component.  Scene.svelte Copy <T.PerspectiveCamera   makeDefault   on:create={({ ref, cleanup }) => {     ref.lookAt(0, 0, 0)     // provide a cleanup function that is called     // when the component is destroyed or `ref`     // changes because different `args` are passed.     cleanup(() => {       console.log('cleanup')     })   }} /> Object Events  Some three.js objects dispatch events such as the OrbitControls. To listen for these events, use a regular Svelte event listener. The following example uses the change event from OrbitControls to invalidate the renderer when the camera is moved.  Scene.svelte Copy <script>   import { T, extend, useThrelte } from '@threlte/core'   import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'   extend({ OrbitControls })   const { renderer, invalidate } = useThrelte() </script> <T.PerspectiveCamera   makeDefault   let:ref >   <T.OrbitControls     args={[ref, renderer.domElement]}     on:change={invalidate}   /> </T.PerspectiveCamera> Click, Pointer and Wheel Events Show Code App.svelte Box.svelte Camera.svelte Scene.svelte Copy <script lang=\"ts\">   import { Canvas, extend } from '@threlte/core'   import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'   import Scene from './Scene.svelte'   extend({     OrbitControls   }) </script> <div class=\"relative h-full w-full\">   <Canvas>     <Scene />   </Canvas>   <div     class=\" absolute top-0 left-0 h-full w-full [&>*]:pointer-events-none\"     id=\"int-target\"   >     <div class=\"relative top-6 left-6\">       <div class=\"text-orange text-sm font-bold uppercase\">Custom Event Target</div>       <div class=\"text-orange text-3xl font-bold\">Event Handling on Foreground Element</div>     </div>   </div> </div>  To add click, pointer and wheel events to your Threlte app, import the plugin interactivity from '@threlte/extras' and call it in your main scene component.  Scene.svelte Copy <script>   import { interactivity } from '@threlte/extras'   interactivity() </script>  All child components now receive events.  Scene.svelte Copy <script>   import { interactivity } from '@threlte/extras'   interactivity() </script> <T.Mesh   on:click={() => {     console.log('clicked')   }} >   <T.BoxGeometry />   <T.MeshStandardMaterial color=\"red\" /> </T.Mesh> Available Events  The following interaction events are available:  Copy <T.Mesh   on:click={(e) => console.log('click')}   on:contextmenu={(e) => console.log('context menu')}   on:dblclick={(e) => console.log('double click')}   on:wheel={(e) => console.log('wheel')}   on:pointerup={(e) => console.log('up')}   on:pointerdown={(e) => console.log('down')}   on:pointerover={(e) => console.log('over')}   on:pointerout={(e) => console.log('out')}   on:pointerenter={(e) => console.log('enter')}   on:pointerleave={(e) => console.log('leave')}   on:pointermove={(e) => console.log('move')}   on:pointermissed={() => console.log('missed')} /> Event Data  All interaction events contain the following data:  Copy type Event = THREE.Intersection & {   intersections: THREE.Intersection[] // The first intersection of each intersected object   object: THREE.Object3D // The object that was actually hit   eventObject: THREE.Object3D // The object that registered the event   camera: THREE.Camera // The camera used for raycasting   delta: THREE.Vector2 //  Distance between mouse down and mouse up event in pixels   nativeEvent: MouseEvent | PointerEvent | WheelEvent // The native browser event   pointer: Vector2 // The pointer position in normalized device coordinates   ray: THREE.Ray // The ray used for raycasting   stopPropagation: () => void // Function to stop propagation of the event   stopped: Boolean // Whether the event propagation has been stopped } Event Propagation  Propagation works a bit differently to the DOM because objects can occlude each other in 3D. The intersections array in the event data includes all objects intersecting the ray, not just the nearest. Only the first intersection with each object is included. The event is first delivered to the object nearest the camera, and then bubbles up through its ancestors like in the DOM. After that, it is delivered to the next nearest object, and then its ancestors, and so on. This means objects are transparent to pointer events by default, even if the object handles the event.  event.stopPropagation() doesn’t just stop this event from bubbling up, it also stops it from being delivered to farther objects (objects behind this one). All other objects, nearer or farther, no longer count as being hit while the pointer is over this object. If they were previously delivered pointerover events, they will immediately be delivered pointerout events. If you want an object to block pointer events from objects behind it, it needs to have an event handler as follows:  Copy <T.Mesh on:click={(e) => e.stopPropagation()} />  even if you don’t want this object to respond to the pointer event. If you do want to handle the event as well as using stopPropagation(), remember that the pointerout events will happen during the stopPropagation() call. You probably want your other event handling to happen after this.  Interactivity Event Target  If no event target is specified, all event handlers listen to events on the domElement of the renderer (which is the canvas element by default). You can specify a different target by passing a target prop to the interactivity plugin.  Scene.svelte Copy <script>   import { interactivity } from '@threlte/extras'   interactivity({     target: document   }) </script>  It’s also possible to change the target at runtime by updating the store target returned from the interactivity plugin.  Scene.svelte Copy <script>   import { interactivity } from '@threlte/extras'   const { target } = interactivity()   $: target.set(document) </script> Interactivity Event Compute  In the event that your event target is not the same size as the canvas, you can pass a compute function to the interactivity plugin. This function receives the DOM event and the interactivity state and should set the pointer property of the state to the pointer position in normalized device coordinates as well as set the raycaster up for raycasting.  Scene.svelte Copy <script>   import { interactivity } from '@threlte/extras'   import { useThrelte } from '@threlte/core'   const { camera } = useThrelte()   interactivity({     compute: (event, state) => {       // Update the pointer       state.pointer.update((p) => {         p.x = (event.clientX / window.innerWidth) * 2 - 1         p.y = -(event.clientY / window.innerHeight) * 2 + 1       })       // Update the raycaster       state.raycaster.setFromCamera(state.pointer.current, $camera)     }   }) </script> Interactivity Event Filtering  You can filter and sort events by passing a filter to the interactivity plugin. The function receives all hits and the interactivity state and should return the hits that should be delivered to the event handlers in the order they should be delivered.  Scene.svelte Copy <script>   import { interactivity } from '@threlte/extras'   interactivity({     filter: (hits, state) => {       // Only return the first hit       return hits.slice(0, 1)     }   }) </script> Interactivity State  To access the interactivity state, you can use the useInteractivity hook in any child component of the component that implements the interactivity plugin as follows:  Child.svelte Copy <script>   import { useInteractivity } from '@threlte/extras'   const { pointer, pointerOverTarget } = useInteractivity()   $: console.log($pointer, $pointerOverTarget) </script>  where this is the type of the interactivity state:  Copy export type State = {   enabled: CurrentWritable<boolean>   target: CurrentWritable<HTMLElement | undefined>   pointer: CurrentWritable<Vector2>   pointerOverTarget: CurrentWritable<boolean>   lastEvent: MouseEvent | WheelEvent | PointerEvent | undefined   raycaster: Raycaster   initialClick: [x: number, y: number]   initialHits: THREE.Object3D[]   hovered: Map<string, IntersectionEvent<MouseEvent | WheelEvent | PointerEvent>>   interactiveObjects: THREE.Object3D[]   compute: ComputeFunction   filter?: FilterFunction }  CurrentWritable is a custom Threlte store. It’s a regular writable store that also has a current property which is the current value of the store. It’s useful for accessing the value of a store in a non-reactive context, such as in loops.  Previous Page Scheduling Tasks Next Page Loading Assets On this page Create Event Object Events Click, Pointer and Wheel Events Available Events Event Data Event Propagation Interactivity Event Target Interactivity Event Compute Interactivity Event Filtering Interactivity State Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/learn/basics/scheduling-tasks","title":"Scheduling Tasks | Learn Threlte","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  Getting Started Introduction Installation Your First Scene Basics App Structure Scheduling Tasks Handling Events Loading Assets Render Modes Disposing Objects Advanced Plugins Custom Abstractions Migration Guides More Resources Basics Scheduling Tasks  In 3D apps and games, a lot of work is done in functions that run on every frame. Web-based apps rely on the browser’s requestAnimationFrame that runs a callback function when a new frame is rendered. When encapsulating logic into smaller parts (i.e. components), we often need to run multiple callbacks that may be dependent on each other. For instance, we may want to update the position of an object based on user input and then render the scene with the updated position.  In Threlte, these functions are called tasks and may or may not follow a specific order. If an order is specified, the respective task has a dependency to other tasks and vice versa. Tasks are grouped into stages and follow the same logic: They may or may not have dependencies to other stages to be executed in a specific order. A Threlte app is managed by a single scheduler.  In this section, we will learn how to use the easy-to-use tools that the Threlte Task Scheduling System provides to create and orchestrate stages and tasks.  Figure: A schedule of multiple stages with tasks Scheduler  Every Threlte app has a single scheduler. It is accessible via useThrelte():  Copy const { scheduler } = useThrelte()  Usually you won’t need to interact with the scheduler directly. It is used internally by Threlte. However, you can use it to create stages and run tasks manually for more advanced use cases.  Stages  Stages are groups of tasks. They are executed in a specific order.  Default Stages  By default, Threlte will create two stages for you:  mainStage: This stage holds all the tasks that are not assigned to any other stage. renderStage: This stage will be executed after the mainStage. It is used to render the scene and only ever executes its tasks when a re-render is needed.  These two stages are created automatically and are accessible via useThrelte():  Copy const { mainStage, renderStage } = useThrelte() Creating a Stage  Sometimes, you may want to create your own stage, for instance to run tasks after rendering. You can do so by using the hook useStage. The hook will create a stage if it does not exist yet, or return the existing stage if it does.  Copy const { renderStage } = useThrelte() const afterRenderStage = useStage('after-render', {   after: renderStage })  All tasks added to the stage afterRenderStage will be executed after the tasks of the stage renderStage.  Be aware that useStage never removes a stage as that’s usually not needed.  A stage decides when and how its tasks are executed. By default, a stage will execute its tasks on every frame. You can change this behavior by passing a callback option to useStage. This callback will be called every frame. The first argument delta is the time elapsed since the last frame. The second argument runTasks is a function that when invoked will run all the tasks of the stage in their respective order. You can use it to run the tasks only when needed (e.g. when a condition is met) or to run them multiple times. If a number is passed as the first argument to runTasks, the tasks will receive that as the delta.  Copy const { renderStage } = useThrelte() const conditionalStage = useStage('after-render', {   after: renderStage,   callback: (delta, runTasks) => {     // This callback will be called every frame. The first argument is the time elapsed     // since the last frame. The second argument is a function that will run all the     // tasks of the stage. You can use it to run the tasks only when needed (e.g. when     // a condition is met) or to run them multiple times. If a number is passed as the     // first argument to runTasks, the tasks will receive that as the delta.     if (condition) {       runTasks()     }   } }) Removing a Stage  You can remove a stage by calling the remove method of the scheduler. The first argument is the stage or the key of the stage to remove.  Copy const { scheduler } = useThrelte() scheduler.removeStage(afterRenderStage)  Be aware that removing a stage will also remove all the tasks in that stage. Usually, you won’t need to remove a stage.  Tasks  Tasks are functions that are executed on every frame. They are grouped in stages. You can add a task to a stage by using the hook useTask. The hook will create a task and add it to a stage.  Default Tasks  By default, Threlte will create a single task for you:  autoRenderTask: This task is part of Threlte’s renderStage and will render the scene if autoRender is set to true.  This task is created automatically and is accessible via useThrelte():  Copy const { autoRenderTask } = useThrelte() Creating an Anonymous Task  In its most basic form, useTask takes a function as its first argument. This function will be executed on every frame, starting on the next frame and receives the delta time representing the time since the last frame as its first argument. By default, the created task is added to Threlte’s mainStage in an arbitrary order (i.e. without dependencies).  Copy const { start, stop, started, task } = useTask((delta) => {   // This function will be executed on every frame })  It returns an object with the following properties:  start: A function that starts the task. It will be executed on the next frame. Note that by default a task is started automatically. stop: A function that stops the task. It will not be executed on the next frame. started: A boolean Svelte Readable store indicating whether the task is started or not. task: The task itself. You can use it to indicate a dependency to this task on another task. Creating a Keyed Task  You can key a task by passing it as the first argument to useTask. This makes referencing this task easier across your app. The key can be any string or symbol value that is unique across all tasks in the stage it is added to.  Copy const {   start,   stop,   started,   task: someTask } = useTask('some-task', (delta) => {   // This function will be executed on every frame }) Creating a Task in a Stage  You can also pass a stage that the task should be added to as an option to useTask:  Copy useTask(   (delta) => {     // This function will be executed on every frame as a     // task in the stage `afterRenderStage`.   },   { stage: afterRenderStage } ) Task Dependencies  A common use case for tasks is to run code after another task has been executed. Imagine a game where an object is transformed by user input in one task and a camera follows that object in another task. The camera task should be executed after the object has been transformed.  To control the order in which tasks are executed in a stage, you can pass a before and after option to useTask. The tasks passed to these options are called dependencies and can be a task itself, the key of a task or an array of tasks or keys. The referenced tasks must be in the same stage as the task you are creating.  Task dependencies do not need to be created yet if they are passed by key. The declared dependencies will be taken into account when they are created later on.  Examples Copy // Execute a task after a single task passed by reference useTask(   (delta) => {     // …   },   { after: someTask } ) Copy // Execute a task after a single task passed by key useTask(   (delta) => {     // …   },   { after: 'some-task' } ) Copy // Execute a task after multiple tasks passed by reference useTask(   (delta) => {     // …   },   { after: [someTask, someOtherTask] } ) Copy // Execute a task after a certain task but before another one useTask(   (delta) => {     // …   },   { after: someTask, before: someOtherTask } ) Copy // Reference a task as a dependency that hasn't been created yet useTask(   (delta) => {     // If a task with the key `some-task` is created later on,     // this task will be executed after it.   },   { before: 'some-task' } ) useTask('some-task', (delta) => {   // … })  If a task is passed by reference to the before or after option, the task created by useTask will automatically be added to the same stage as the task it depends on. If you pass a key instead and the task you want to reference is not in Threlte’s mainStage, you will also need to pass the stage, either by value or key.  Reviewing the schedule  To debug the execution order, you can use the getSchedule method of the scheduler at any time.  Copy const { scheduler } = useThrelte() scheduler.getSchedule({   tasks: true }) Result Copy {   \"stages\": [     {       \"key\": \"physics stage\",       \"tasks\": [\"physics\"]     },     {       \"key\": \"main stage\",       \"tasks\": [\"move object\", \"move camera\"]     },     {       \"key\": \"render stage\",       \"tasks\": [\"render\"]     }   ] }  In this example, the effective task execution order is:  physics move object move camera render  The design of the Threlte Task Scheduling System is a collaborative effort of the Threlte team, Kris Baumgarter and Akshay Dhalwala.  Previous Page App Structure Next Page Handling Events On this page Scheduler Stages Default Stages Creating a Stage Removing a Stage Tasks Default Tasks Creating an Anonymous Task Creating a Keyed Task Creating a Task in a Stage Task Dependencies Reviewing the schedule Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/reference/core/getting-started","title":"Getting Started | @threlte/core","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  @threlte/core Getting Started COMPONENTS <Canvas> <T> HOOKS useThrelte useStage useTask useLoader useThrelteUserContext HELPERS Plugins Utilities Hierarchy LEGACY useFrame useRender @threlte/core Getting Started  The package @threlte/core is the core package of the Threlte framework. It provides the basic functionality of the framework, such as the <Canvas> and <T> components, and hooks to interact with the Threlte state.  Installation Terminal Copy npm install @threlte/core three @types/three Usage  Every Threlte application must be wrapped in a <Canvas> component. This component is responsible for creating THREE.WebGLRenderer and providing a state for every child component.  App.svelte Copy <script lang=\"ts\">   import { Canvas } from '@threlte/core'   import Scene from './Scene.svelte' </script> <Canvas>   <Scene /> </Canvas>  The main building block of a Threlte application is the <T> component. Use this component to instantiate any Three.js object available in the THREE namespace.  Scene.svelte Copy <script lang=\"ts\">   import { T } from '@threlte/core' </script> <T.PerspectiveCamera   position={[10, 10, 10]}   on:create={({ ref }) => {     ref.lookAt(0, 0, 0)   }} /> <T.Mesh>   <T.BoxGeometry args={[1, 1, 1]} />   <T.MeshBasicMaterial color=\"red\" /> </T.Mesh> Next Page Components On this page Installation Usage Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/reference/flex/getting-started","title":"Getting Started | @threlte/flex","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  @threlte/flex Getting Started Examples COMPONENTS <Flex> <Box> UTILITIES createClassParser tailwindParser HOOKS useReflow useDimensions @threlte/flex Getting Started  Placing content and making layouts in 3D is hard. The flexbox engine Yoga is a cross-platform layout engine which implements the flexbox spec. The package @threlte/flex provides components to easily use Yoga in Threlte.  Show Code App.svelte Button.svelte Circle.svelte Label.svelte Matcap.svelte Plane.svelte RoundedPlane.svelte Scene.svelte Window.svelte Copy <script lang=\"ts\">   import { useTask, useThrelte } from '@threlte/core'   import { interactivity, transitions } from '@threlte/extras'   import { Box } from '@threlte/flex'   import { tick } from 'svelte'   import Button from './Button.svelte'   import Label from './Label.svelte'   import Matcap from './Matcap.svelte'   import Window from './Window.svelte'   export let windowWidth: number   export let windowHeight: number   export let rows = 5   export let columns = 5   export let size: any   let page = 1   $: offset = (page - 1) * rows * columns   interactivity()   transitions()   const { renderStage, autoRender, renderer, scene, camera } = useThrelte()   autoRender.set(false)   useTask(     async () => {       await tick()       renderer.render(scene, camera.current)     },     { stage: renderStage, autoInvalidate: false }   ) </script> <Window   title=\"Matcaps\"   width={windowWidth}   height={windowHeight} >   <Box class=\"h-full w-full flex-col items-stretch gap-10 p-10\">     {#each new Array(rows) as _, rowIndex}       <Box class=\"h-auto w-full flex-1 items-center justify-evenly gap-10\">         {#each new Array(columns) as _, columnIndex}           {@const index = rowIndex * columns + columnIndex}           <Box             class=\"h-full w-full flex-1\"             let:width             let:height           >             <Matcap               {width}               {height}               matcapIndex={offset + index}               gridIndex={index}               format={size}             />           </Box>         {/each}       </Box>     {/each}     <Box       order={999}       class=\"h-40 w-auto items-center justify-center gap-10\"     >       <Button         class=\"h-full w-auto flex-1\"         z={15}         text=\"← PREVIOUS PAGE\"         order={0}         on:click={() => {           page = Math.max(1, page - 1)         }}       />       <Box         class=\"h-full w-auto flex-1\"         order={1}       >         <Label           z={10.1}           fontSize=\"xl\"           text={`PAGE: ${page}`}         />       </Box>       <Button         class=\"h-full w-auto flex-1\"         z={15}         text=\"NEXT PAGE →\"         order={2}         on:click={() => {           page = Math.min(10, page + 1)         }}       />     </Box>   </Box> </Window> MatCap textures from https://github.com/emmelleppi/matcaps Installation Copy npm install @threlte/flex Usage Basic Example  Use the component <Flex> to create a flexbox container. Since there’s no viewport to fill, you must specify the size of the container. Add flex items with the component <Box>.  Copy <script lang=\"ts\">   import { Flex } from '@threlte/flex'   import Plane from './Plane.svelte' </script> <Flex   width={100}   height={100} >   <Box>     <Plane       width={20}       height={20}     />   </Box>   <Box>     <Plane       width={20}       height={20}     />   </Box> </Flex> Flex Props  The components <Flex> and <Box> accept props to configure the flexbox. If no width or height is specified on <Box> components, a bounding box is used to determine the size of the flex item. The computed width or height may be different from what is specified on the <Box> component, depending on the flexbox configuration. To make use of the calculated dimensions of a flex item, use the slot props width and height.  Copy <Flex   width={100}   height={100}   flexDirection=\"Column\"   justifyContent=\"SpaceEvenly\"   alignItems=\"Stretch\" >   <Box     width=\"auto\"     height=\"auto\"     flex={1}     let:width     let:height   >     <Plane       {width}       {height}     />   </Box>   <Box     width=\"auto\"     height=\"auto\"     flex={1}     let:width     let:height   >     <Plane       {width}       {height}     />   </Box> </Flex> Nested Flex  Every <Box> component is also a flex container. Nesting <Box> components allows you to create complex layouts.  Copy <Flex   width={100}   height={100}   flexDirection=\"Column\"   justifyContent=\"SpaceEvenly\"   alignItems=\"Stretch\" >   <Box     width=\"auto\"     height=\"auto\"     flex={1}     justifyContent=\"SpaceEvenly\"     alignItems=\"Stretch\"     padding={20}     margin={20}     gap={20}     let:width     let:height   >     <Plane       color=\"orange\"       {width}       {height}       depth={1}     />     <Box       height=\"auto\"       flex={1}       let:width       let:height     >       <Plane         color=\"blue\"         {width}         {height}         depth={2}       />     </Box>     <Box       height=\"auto\"       flex={1}       let:width       let:height     >       <Plane         color=\"red\"         {width}         {height}         depth={2}       />     </Box>   </Box>   <Box     height=\"auto\"     width=\"auto\"     flex={1}     let:width     let:height   >     <Plane       depth={1}       {width}       {height}     />   </Box> </Flex> Align Flex Container  The component <Align> can be used to align the resulting flex container.  Copy <script lang=\"ts\">   import { Align } from '@threlte/extras'   import { Flex } from '@threlte/flex'   import Plane from './Plane.svelte' </script> <Align   y={1}   let:align >   <Flex     width={100}     height={100}     on:reflow={align}   >     <Box>       <Plane         width={20}         height={20}       />     </Box>     <Box>       <Plane         width={20}         height={20}       />     </Box>   </Flex> </Align> Using the Prop class  The prop class can be used on <Box> and <Flex> to easily configure the flexbox with predefined class names just as you would do in CSS. In order to use the prop, you need to create a ClassParser using the utility createClassParser which accepts a single string and returns NodeProps. Let’s assume, you want to create a parser that supports the following class names:  Copy .container {   display: flex;   flex-direction: row;   justify-content: center;   align-items: stretch;   gap: 10px;   padding: 10px; } .item {   width: auto;   height: auto;   flex: 1; }  You then need to create a ClassParser which returns the corresponding props:  Copy import { createClassParser } from '@threlte/flex' const classParser = createClassParser((string, props) => {   const classNames = string.split(' ')   for (const className of classNames) {     switch (className) {       case 'container':         props.flexDirection = 'Row'         props.justifyContent = 'Center'         props.alignItems = 'Stretch'         props.gap = 10         props.padding = 10         break       case 'item':         props.width = 'auto'         props.height = 'auto'         props.flex = 1     }   }   return props })  Now you can use the prop class on <Flex> and <Box> to configure the flexbox:  Copy <Flex   width={100}   height={100}   {classParser}   class=\"container\" >   <Box class=\"item\">     <Plane       width={20}       height={20}     />   </Box>   <Box class=\"item\">     <Plane       width={20}       height={20}     />   </Box> </Flex>  @threlte/flex ships with a default ClassParser which supports Tailwind-like class names.  Previous Page useTeleport Next Page Examples On this page Installation Usage Basic Example Flex Props Nested Flex Align Flex Container Using the Prop class Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/learn/getting-started/introduction","title":"Introduction | Learn Threlte","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  Getting Started Introduction Installation Your First Scene Basics App Structure Scheduling Tasks Handling Events Loading Assets Render Modes Disposing Objects Advanced Plugins Custom Abstractions Migration Guides More Resources Getting Started Introduction  Threlte is a renderer and component library for using Three.js in a declarative and state-driven way in Svelte apps. It provides strictly typed components for deep reactivity and interactivity out-of-the-box.  Threlte is comprised of six distinct packages to allow you to import only what you need:  @threlte/core is the heart of Threlte, providing simple transparent Svelte binding to Three.js:  <T> is the main building block of any Threlte application. It is a thin wrapper around any Three.js object and provides a declarative API to build and render your Threlte app.  Plugins make it easy to extend Threlte with custom code and logic. Whether you want to implement an ECS or add a single property to every instance of <T>, plugins are the way to go.  @threlte/extras is a collection of plugins and components that extend Threlte with additional functionality.  @threlte/gltf is a command-line tool that turns GLTF assets into declarative and re-usable Threlte components.  @threlte/rapier provides components to enable performant physics in your Threlte application through the Rapier engine  @threlte/theatre provides components to enable animations in your Threlte application through the Theatre.js animation library  @threlte/xr provides components for VR and AR.  @threlte/flex provides components to easily use the flex engine yoga-layout with Threlte.  Next Page Installation Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/reference/theatre/getting-started","title":"Getting Started | @threlte/theatre","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  @threlte/theatre Getting Started COMPONENTS <Theatre> <Project> <Sheet> <Sequence> <Studio> SHEET OBJECT <SheetObject> <Sync> <Transform> <Declare> HOOKS useStudio useSequence ACTIONS sheetObjectAction @threlte/theatre Getting Started  Theatre.js is a javascript animation library with a professional motion design toolset. It helps you create any animation, from cinematic scenes in 3D, to delightful UI interactions.  Concepts  As with the rest of Threlte, @threlte/theatre provides an idiomatic yet transparent Svelte wrapper. The core concepts of @threlte/theatre are:  @threlte/theatre Component Description Corresponding Theatre.js Concept(s) <Project> Contains your project’s animation sheets Project <Sheet> Binds to an animation sheet that contains animation sequences Sheet <Sequence> Binds to an animation sequence and contains the animated components Sequence <Studio> Enables the Theatre.js in-browser studio interface during development Studio <SheetObject> Enables editing and animating its parent in the studio interface Sheet Object <Theatre> A helper component providing a project with a single sheet and a studio Project, Sheet, Studio  The @threlte/theatre documentation cross-references the Theatre.js documentation, allowing you to get a deeper understanding of the underlying concepts.  Workflow  Theatre.js combines programming in your IDE with editing in a browser-based GUI. The core workflow looks something like this:  Create your scene as usual, placing a <Project> and one or more <Sheets> in your <Canvas>. Identify the elements and props you wish to edit in the <Studio>, and place an <SheetObject> component around them, then use the slotted components <Sync>, <Declare> or <Transform> to add editable props. Edit props and animations of elements in the <Studio> in the browser; config state is autosaved to local storage. Export the updated state as a JSON file by selecting your project in the studio and clicking export (top-right corner). Import your scene’s state.json and use it in your <Project>’s config prop. Installation Copy npm install @threlte/theatre @theatre/core @theatre/studio Quick Start  To get started quickly, encapsulate your whole scene in the component <Theatre>.  The component <Theatre> provides a default <Project> and <Sheet> and implements <Studio>. For a more flexible structure please consider using <Project>, <Sheet> and <Studio> on their own.  App.svelte Copy <script lang=\"ts\">   import { Canvas } from '@threlte/core'   import { Theatre } from '@threlte/theatre'   import Scene from './Scene.svelte' </script> <Canvas>   <Theatre>     <Scene />   </Theatre> </Canvas>  In your Scene, add the component <SheetObject> as a parent of any component you’d wish to edit or animate. The component <SheetObject> provides the components <Sync>, <Declare> and <Transform> that allow you to manipulate properties in Theatre.js based on your Threlte markup.  The component <Transform> is a shortcut to add position, scale and rotation at once as well as mount handy <TransformControls> whenever the respective Sheet Object is selected in the studio.  Scene.svelte Copy <script lang=\"ts\">   import { T } from '@threlte/core'   import { OrbitControls } from '@threlte/extras'   import { SheetObject } from '@threlte/theatre' </script> <T.PerspectiveCamera   position={[0, 5, 10]}   makeDefault >   <OrbitControls target={{ y: 1.5 }} /> </T.PerspectiveCamera> <!-- Box --> <SheetObject   key=\"Box\"   let:Transform   let:Sync >   <Transform>     <T.Mesh       receiveShadow       castShadow       position.y={0.5}     >       <T.BoxGeometry args={[1, 1, 1]} />       <T.MeshStandardMaterial color=\"#b00d03\">         <Sync           color           roughness           metalness         />       </T.MeshStandardMaterial>     </T.Mesh>   </Transform> </SheetObject>  You will now see the Theatre.js studio interface. Make yourself comfortable with the controls and if you haven’t done yet, please read the Theatre.js studio manual and keyboard shortcuts.  Previous Page usePrismaticJoint Next Page Components On this page Concepts Workflow Installation Quick Start Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/examples/meshline/cursor-lines","title":"Cursor Lines | Threlte Example","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  Misc Gaussian Splatting Tutorials Animating a Spaceship animation Animation Transitions camera Pointer Lock Controls ThirdPersonCamera camera-controls geometry LOD Random Placement Rendering Points Terrain with 3D noise Terrain with Rapier physics meshline Cursor Lines postprocessing Outlines renderers CSS2DRenderer Overlay shaders Interactive shader Cursor Lines  Here we use <MeshLineGeometry> and <MeshLineMaterial> to create a scene where a group of lines follow the cursor. Inspired by the OGL PolyLines example.  Show Code App.svelte CursorLine.svelte Scene.svelte Copy <script lang=\"ts\">   import { Canvas } from '@threlte/core'   import Scene from './Scene.svelte' </script> <div>   <Canvas>     <Scene />   </Canvas> </div> <style>   div {     height: 100%;   } </style> How does it work?  First we create a scene with an OrthographicCamera and a Mesh that will act as our background. We move the camera up in the Y axis and use the lookAt property to point the camera back down at the Mesh. We use a BoxGeometry large enough in the X and Z axis to fill the screen.  Copy <T.OrthographicCamera   zoom={50}   makeDefault   position.y={10}   on:create={({ ref }) => {     ref.lookAt(new Vector3(0, 0, 0))   }} /> <T.Mesh>   <T.BoxGeometry args={[20, 0.1, 20]} />   <T.MeshBasicMaterial /> </T.Mesh> Get the cursor position  To get the cursor position we use Threlte’s interacivity plugin.  Copy <script lang=\"ts\">   interactivity()   let cursorPosition = { x: 0, z: 0 } </script> <T.Mesh   visible={false}   on:pointermove={(e) => {     cursorPosition.x = e.point.x     cursorPosition.z = e.point.z   }} >   <T.BoxGeometry args={[20, 0.1, 20]} />   <T.MeshBasicMaterial /> </T.Mesh> Create our CursorLine component  We create a component called CursorLine where we will implement <MeshLineMaterial> and <MeshLineGeometry> to create out lines. We need to initialise the <MeshLineGeometry> component with an array of points so we create an array of points positioned at x:0, y:0, z:0. To give each line a different color and with we export these propertys to be set in our parent scene, along with the cursorPosition.  Copy <script lang=\"ts\">   export let cursorPosition: { x: number; z: number }   export let color: string   export let width: number   let points: Vector3[] = []   for (let j = 0; j < 50; j++) {     points.push(new Vector3(0, 0, 0))   } </script> <T.Mesh {...$$restProps}>   <MeshLineGeometry     {points}     shape={'taper'}   />   <MeshLineMaterial     {width}     {color}     scaleDown={0.1}     attenuate={false}   /> </T.Mesh>  To give each line a bit of individual character we can use Svelte’s spring function. We will set the stiffness and dampening values in the parent scene.  Copy export let stiffness: number export let damping: number // Here we create our new svelte store that will // automatically 'spring' any future values we set let sprungCursor = spring(   { x: 0, z: 0 },   {     stiffness,     damping   } ) // We set the sprungCursor value to the // cursorPosition whenever it updates $: sprungCursor.set(cursorPosition)  Now we need to move our line!  We do this by linking the first point in the line to our cursor position. For the rest of the points in the line we use the lerp function to move each point towards the one before it. The lerp function is a method of THREE.Vector3 and is useful for moving an object towards a set point each frame.  Copy $: {   if (points[0]) {     // We set the first point in the array to equal     // our sprungCursor store whenever it updates     points[0].x = $sprungCursor.x     points[0].z = $sprungCursor.z     points = points   } } useTask(() => {   let previousPoint = points[0]   // Every frame we loop through each point ...   points.forEach((point, i) => {     if (previousPoint && i > 0) {       // ... and for every point (except the first)       // we lerp it towards the point before it       point.lerp(previousPoint, 0.75)       previousPoint = point     }   })   points = points }) Link it all together  All that is left to do is to is implement our new CursorLine component in our scene. To create our five lines we create an array of five colors, then loop through them to create out CursorLine components. We use the index to give each line slightly different position, stiffness, dampening and width propertys.  Copy <script lang=\"ts\">   let colors = ['#fc6435', '#ff541f', '#f53c02', '#261f79', '#1e165c'] </script> {#each colors as color, i}   <CursorLine     {color}     {cursorPosition}     position.y={5 - i}     stiffness={0.02 * i + 0.02}     damping={0.25 - 0.04 * i}     width={15 + i * 10}   /> {/each} Previous Page Terrain with Rapier physics Next Page Outlines On this page How does it work? Get the cursor position Create our CursorLine component Link it all together Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/examples/geometry/terrain-with-rapier-physics","title":"Terrain with Rapier physics | Threlte Example","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  Misc Gaussian Splatting Tutorials Animating a Spaceship animation Animation Transitions camera Pointer Lock Controls ThirdPersonCamera camera-controls geometry LOD Random Placement Rendering Points Terrain with 3D noise Terrain with Rapier physics meshline Cursor Lines postprocessing Outlines renderers CSS2DRenderer Overlay shaders Interactive shader Terrain with Rapier physics  This example shows how to include user-generated random terrain as a fixed <RigidBody>, within a Rapier world.  This is an adaption of Rapier’s own demo (select “Demo: triangle mesh”).  Show Code App.svelte FallingShapes.svelte Scene.svelte Copy <script lang=\"ts\">   import { Canvas } from '@threlte/core'   import { World } from '@threlte/rapier'   import Scene from './Scene.svelte'   import { Pane, Button } from 'svelte-tweakpane-ui'   let reset: () => any | undefined   let toggleDebug: () => any | undefined </script> <Pane   title=\"\"   position=\"fixed\" >   <Button     title=\"Reset\"     on:click={reset}   />   <Button     title=\"Toggle Debug\"     on:click={toggleDebug}   /> </Pane> <div>   <Canvas>     <World>       <Scene         bind:reset         bind:toggleDebug       />     </World>   </Canvas> </div> <style>   div {     height: 100%;   } </style> Copy <script lang=\"ts\">   import { T } from '@threlte/core'   import { Collider, RigidBody, AutoColliders } from '@threlte/rapier'  import { BoxGeometry, SphereGeometry, CylinderGeometry, ConeGeometry} from 'three'   const radius = 0.25   const shapes = [     {    geometry: new BoxGeometry(radius, radius, radius),    autoCollider: 'cuboid',    color: 'hotpink',   },     {    geometry: new SphereGeometry(radius),    autoCollider: 'ball',    color: 'cyan',   },    {    geometry: new CylinderGeometry(radius, radius, radius * 2),       autoCollider: 'convexHull',       color: 'green',     },     {    geometry: new ConeGeometry(radius, radius * 3, 10),    autoCollider: 'convexHull',    color: 'orange',   }   ]   const bodies = new Array(50).fill(0).map((_, index) => {     const position: Parameters<Vector3['set']> = [       Math.random() * 5 - 2.5,       Math.random() * 5,       Math.random() * 5 - 2.5     ]     const rotation: Parameters<Euler['set']> = [       Math.random() * 10,       Math.random() * 10,       Math.random() * 10     ]     const shape = shapes[Math.floor(Math.random() * shapes.length)]     return {       id: index,       position,       rotation,       ...shape     }   }) </script> {#each bodies as body (body.id)}   <T.Group     position={body.position}     rotation={body.rotation}   >     <RigidBody type={'dynamic'}>       <AutoColliders shape={body.autoCollider}>         <T.Mesh           castShadow           receiveShadow      geometry={body.geometry}         >           <T.MeshStandardMaterial color={body.color} />         </T.Mesh>       </AutoColliders>     </RigidBody>   </T.Group> {/each} Copy <script lang=\"ts\">   import { PlaneGeometry, MeshStandardMaterial } from 'three'   import { DEG2RAD } from 'three/src/math/MathUtils'   import { createNoise2D } from 'simplex-noise'   import { T } from '@threlte/core'   import { OrbitControls } from '@threlte/extras'   import RAPIER from '@dimforge/rapier3d-compat'   import { Collider, Debug, RigidBody } from '@threlte/rapier'   import FallingShapes from './FallingShapes.svelte'   let nsubdivs = 10   let heights = []   const geometry = new PlaneGeometry(10, 10, nsubdivs, nsubdivs)   const noise = createNoise2D()   const vertices = geometry.getAttribute('position').array   for (let x = 0; x <= nsubdivs; x++) {     for (let y = 0; y <= nsubdivs; y++) {       let height = noise(x, y)       const vertIndex = (x + (nsubdivs + 1) * y) * 3       //@ts-ignore       vertices[vertIndex + 2] = height       const heightIndex = y + (nsubdivs + 1) * x       heights[heightIndex] = height     }   }   // needed for lighting   geometry.computeVertexNormals()   const scale = new RAPIER.Vector3(10.0, 1, 10)   let resetCounter = 0   export const reset = () => {     resetCounter += 1   }   let debugEnabled = false   export const toggleDebug = () => {     debugEnabled = !debugEnabled   } </script> <T.PerspectiveCamera   makeDefault   position.y={10}   position.z={10}   lookAt.y={0} >   <OrbitControls enableZoom={true} /> </T.PerspectiveCamera> <T.DirectionalLight position={[3, 10, 10]} /> <T.HemisphereLight intensity={0.2} /> {#key resetCounter}   <FallingShapes /> {/key} <T.Mesh   receiveShadow   {geometry}   rotation.x={DEG2RAD * -90}   rotation.z={DEG2RAD * 0} >   <T.MeshStandardMaterial     color=\"teal\"     opacity=\"0.8\"     transparent   /> </T.Mesh> <RigidBody type={'fixed'}>   <Collider     shape={'heightfield'}     args={[nsubdivs, nsubdivs, heights, scale]}   /> </RigidBody> {#if debugEnabled === true}   <Debug /> {/if} How does it work Similar to the 3D noise example, loop over the vertices of a PlaneGeometry, and use a noise map to create a heightfield array heights. Attach the heightfield to a rapier <Collider> Copy <Collider   shape={'heightfield'}   args={[nsubdivs, nsubdivs, heights, scale]} /> Wrap in a fixed <RigidBody>. We don’t want this terrain to respond to gravity and fall downwards when rapier physics simulation begins. Copy <RigidBody type={'fixed'}>   <Collider ... /> </RigidBody> Add some falling random shapes to the scene to prove that the terrain is functioning properly (see “FallingShapes.svelte”)  define some shapes in an array  geometry <AutoCollider> type color  fill an array of 50 items with a random shape, with a random position and rotation, and loop over it in markup  add a <T.Mesh> to the scene, provide it with the chosen geometry, and a material with the chosen color  wrap that in an <AutoColliders> with the chosen AutoCollider  wrap in a 'dynamic' <RigidBody>. Dynamic because we want these shapes to fall in the scene according to gravity.  finally, wrap in a <T.Group> to set our random position and rotation  Previous Page Terrain with 3D noise Next Page Cursor Lines On this page How does it work Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/examples/tutorials/animating-a-spaceship","title":"Animating a Spaceship | Threlte Example","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  Misc Gaussian Splatting Tutorials Animating a Spaceship animation Animation Transitions camera Pointer Lock Controls ThirdPersonCamera camera-controls geometry LOD Random Placement Rendering Points Terrain with 3D noise Terrain with Rapier physics meshline Cursor Lines postprocessing Outlines renderers CSS2DRenderer Overlay shaders Interactive shader Animating a Spaceship  This tutorial demonstrates how to load and animate a spaceship model, as well as using Threlte’s InstancedMesh to efficiently animate hundreds of stars. We’ll also cover raycaster intersections, post-processing effects, and dynamically generated reflection maps.  Show Code models credits.md spaceship.svelte App.svelte Scene.svelte Stars.svelte Copy <script>   import { Canvas } from '@threlte/core'   import Scene from './Scene.svelte' </script> <div>   <Canvas>     <Scene />   </Canvas> </div> <style>   div {     width: 100%;     height: 100%;   } </style> Part I Part II  The second part of the tutorial focuses on applying a spring-based animation to the spaceship model by leveraging useFrame, a Threlte 6 hook used to run a callback on every frame. Threlte 7 improved the task scheduling API by introducing useTask, for newer Threlte projects it’s recommended to replace the useFrame line shown in the video with the updated API.  Threlte 6 Copy useFrame(() => {   ... }) Threlte 7 Copy useTask(() => {   ... }) Part III  In this last portion of the tutorial we’ll introduce post-processing effects that require control over the render loop, and similiarly to episode 2 the video relies on useRender, a Threlte 6 hook used to manually render a scene. The equivalent Threlte 7 logic adds a task to Threlte’s default renderStage  Threlte 6 Copy const { scene, camera, renderer } = useThrelte() useRender(() => {   // render here }) Threlte 7 Copy const { scene, camera, renderer, renderStage } = useThrelte() useTask(   () => {     // render here   },   { stage: renderStage, autoInvalidate: false } ) Previous Page Gaussian Splatting Next Page Animation Transitions On this page Part I Part II Part III Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/examples/geometry/terrain-with-3d-noise","title":"Terrain with 3D noise | Threlte Example","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  Misc Gaussian Splatting Tutorials Animating a Spaceship animation Animation Transitions camera Pointer Lock Controls ThirdPersonCamera camera-controls geometry LOD Random Placement Rendering Points Terrain with 3D noise Terrain with Rapier physics meshline Cursor Lines postprocessing Outlines renderers CSS2DRenderer Overlay shaders Interactive shader Terrain with 3D noise  The key to creating “random” yet smooth terrain is using “noise”.  To create a terrain map, we want to be able to input the x and y coordinate , and return a height value. Therefore we want to utilise 2D noise, and this example uses the function createNoise2D from the package simplex-noise.  Show Code App.svelte Scene.svelte state.ts Copy <script lang=\"ts\">   import { Canvas } from '@threlte/core'   import { World } from '@threlte/rapier'   import Scene from './Scene.svelte'   import { Pane, Checkbox } from 'svelte-tweakpane-ui'   import { showCollider, autoRotate } from './state' </script> <Pane   title=\"\"   position=\"fixed\" >   <Checkbox     label=\"Show Collider\"     bind:value={$showCollider} /> <Checkbox label=\"AutoRotate\" bind:value={$autoRotate}   /> </Pane> <div>   <Canvas>     <World>       <Scene />     </World>   </Canvas> </div> <style>   div {     height: 100%;   } </style> How is this done?  In Scene.svelte:  Create noise map  const noise = createNoise2D()  Create plane geometry  const geometry = new PlaneGeometry(10, 10, 100, 100)  Reminder that planes are on their side by default!  i.e. they extend in the x and y directions, and the z value of each vertex is 0  Extract the “position” (vertices) array from the PlaneGeometry  const geometry = geometry.getAttribute('position').array  Loop over the vertices, setting each z value, using our noise map  Copy for (let i = 0; i < vertices.length; i += 3) {   const x = vertices[i]   const y = vertices[i + 1]   // @ts-ignore   vertices[i + 2] = noise(x / 4, y / 4) }  Why i+=3?  The position array is a flat array of vertices, in the recurring format “x y z x y z…” So if we want to set each vertex’s z value from it’s x and y, we need to loop in triplets.  Attach the plane geometry to a mesh, and rotate Copy <T.Mesh  {geometry}  rotation.x={DEG2RAD * -90} >  This example intentionally used only part of the noise map (the middle 25%), in order to generate gentler terrain.  To “see” the noise map in full, change noise(x/4, y/4) to noise(x, y).  You’ll see that the terrain is much more hilly!  Previous Page Rendering Points Next Page Terrain with Rapier physics On this page How is this done? Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/examples/misc/gaussian-splatting","title":"Gaussian Splatting | Threlte Example","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  Misc Gaussian Splatting Tutorials Animating a Spaceship animation Animation Transitions camera Pointer Lock Controls ThirdPersonCamera camera-controls geometry LOD Random Placement Rendering Points Terrain with 3D noise Terrain with Rapier physics meshline Cursor Lines postprocessing Outlines renderers CSS2DRenderer Overlay shaders Interactive shader Gaussian Splatting  3D Gaussian Splatting is a rasterization technique that allows to render 3D objects with a high level of detail. It’s a technology that is currently quickly gaining popularity because of the photorealistic rendering of 3D scan data. This example shows how to implement 3D Gaussian Splatting with the help of two libraries:  @lumaai/luma-web by Luma @pmndrs/vanilla  The technology presented in this example is rapidly developing and therefore the components are not part of the @threlte/extras package as of now. You may however copy and paste them into your project and use them as you wish.  LumaSplatsThree LumaSplatsThree.svelte LumaSplatsThree.svelte.d.ts Splat Splat.svelte Splat.svelte.d.ts App.svelte RenderIndicator.svelte Scene.svelte Copy <script lang=\"ts\">   import { T } from '@threlte/core'   import { GLTF, OrbitControls } from '@threlte/extras'   import { Checkbox, Folder, FpsGraph, List, Pane, Slider } from 'svelte-tweakpane-ui'   import type { MeshStandardMaterial } from 'three'   import { DEG2RAD } from 'three/src/math/MathUtils.js'   import LumaSplats from './LumaSplatsThree/LumaSplatsThree.svelte'   import RenderIndicator from './RenderIndicator.svelte'   import Splat from './Splat/Splat.svelte'   // <LumaSplatsThree>   let showLumaSplats = true   let lumaSplatsMode: 'object' | 'object-env' | 'env' = 'object-env'   // <Splat>   let showSplat = true   let alphaHash = false   let alphaTest = 0.06   let toneMapped = true   // Car   let showPorsche = true   let gltfMaterials: Record<string, MeshStandardMaterial> | undefined   $: if (gltfMaterials) {     Object.values(gltfMaterials).forEach((material) => {       material.envMapIntensity = 5     })   } </script> <LumaSplats   visible={showLumaSplats}   source=\"https://lumalabs.ai/capture/4c15c22e-8655-4423-aeac-b08f017dda22\"   mode={lumaSplatsMode} /> <Splat   visible={showSplat}   position={[1.08, 2.21, -1.99]}   rotation={[-32.3 * DEG2RAD, -18.5 * DEG2RAD, -6.4 * DEG2RAD]}   src=\"https://huggingface.co/cakewalk/splat-data/resolve/main/nike.splat\"   {alphaHash}   alphaTest={alphaTest > 0 ? alphaTest : undefined}   {toneMapped} /> <GLTF   visible={showPorsche}   position={[-1.48, -0.51, 2.15]}   rotation.y={57 * DEG2RAD}   scale={0.7}   bind:materials={gltfMaterials}   url=\"/models/splat-example/porsche_959.glb\" /> <T.PerspectiveCamera   makeDefault   position={[0.22, 2.44, 9.06]}   on:create={({ ref }) => {     ref.lookAt(0, 0, 0)   }}   fov={25} >   <OrbitControls /> </T.PerspectiveCamera> <!-- TWEAKPANE --> <Pane   position=\"fixed\"   title=\"Gaussian Splatting\"   expanded={false} >   <Folder     userExpandable={false}     expanded     title=\"Luma\"   >     <Checkbox       bind:value={showLumaSplats}       label=\"Show LumaSplats\"     />     {#if showLumaSplats}       <List         bind:value={lumaSplatsMode}         options={{           object: 'object',           'object-env': 'object-env',           env: 'env'         }}       />     {/if}   </Folder>   <Folder     userExpandable={false}     expanded     title=\"Splat\"   >     <Checkbox       bind:value={showSplat}       label=\"Show Splats\"     />     {#if showSplat}       <Checkbox         bind:value={alphaHash}         label=\"alphaHash\"       />       <Slider         bind:value={alphaTest}         label=\"alphaTest\"         min={0}         max={1}         step={0.01}       />       <Checkbox         bind:value={toneMapped}         label=\"toneMapped\"       />     {/if}   </Folder>   <Folder title=\"Porsche\">     <Checkbox       bind:value={showPorsche}       label=\"Show Porsche\"     />   </Folder>   <Folder title=\"Rendering Activity\">     <RenderIndicator />     <FpsGraph />   </Folder> </Pane>  Models:  Scene: https://lumalabs.ai/capture/4c15c22e-8655-4423-aeac-b08f017dda22 Shoe: https://huggingface.co/cakewalk Porsche: https://sketchfab.com/3d-models/porsche-959-0530aa8fa4b74427a71c961a5bdd7087 Next Page Animating a Spaceship Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/examples/camera/pointer-lock-controls","title":"Pointer Lock Controls | Threlte Example","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  Misc Gaussian Splatting Tutorials Animating a Spaceship animation Animation Transitions camera Pointer Lock Controls ThirdPersonCamera camera-controls geometry LOD Random Placement Rendering Points Terrain with 3D noise Terrain with Rapier physics meshline Cursor Lines postprocessing Outlines renderers CSS2DRenderer Overlay shaders Interactive shader Pointer Lock Controls  A remix of threejs’ PointerLockControls. It uses the Pointer Lock API.  Use-case  Controlling the camera in a 1st-person video game.  click the scene to lock the pointer to the scene press ‘Esc’ to release pointer Show Code App.svelte Player.svelte PointerLockControls.svelte Scene.svelte Copy <script lang=\"ts\">   import { Pane, Text } from 'svelte-tweakpane-ui'   import { Canvas } from '@threlte/core'   import { World } from '@threlte/rapier'   import Scene from './Scene.svelte' </script> <Pane   position=\"fixed\"   title=\"pointer-lock\" >   <Text     value=\"Use the 'wasd' keys to move around\"     disabled   /> </Pane> <div>   <Canvas>     <World>       <Scene />     </World>   </Canvas> </div> <style>   div {     position: relative;     height: 100%;     width: 100%;   } </style> Explanation  When the scene is clicked, the pointer is locked to the scene, and now pointer movements will control the angle of the camera in the scene.  there is no need to click and drag, like with e.g. OrbitControls.  Pointer lock lets you access mouse events even when the cursor goes past the boundary of the browser or screen  To explain the 2nd point, find a Threlte scene which uses OrbitControls for it’s camera. Now click and drag the cursor left until you hit the edge of your screen. When you hit the edge, the camera will stop rotating. But in a video game, we want to be able to for example, turn to spin clockwise as many times as we like. Hence why we need to lock the pointer.  This pointer locking behaviour is performed by basically any native video game when it is run on a computer.  Previous Page Animation Transitions Next Page ThirdPersonCamera On this page Use-case Explanation Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/examples/geometry/lod","title":"LOD | Threlte Example","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  Misc Gaussian Splatting Tutorials Animating a Spaceship animation Animation Transitions camera Pointer Lock Controls ThirdPersonCamera camera-controls geometry LOD Random Placement Rendering Points Terrain with 3D noise Terrain with Rapier physics meshline Cursor Lines postprocessing Outlines renderers CSS2DRenderer Overlay shaders Interactive shader LOD  This is a practical example showing a best-practice method of implementing LOD in Threlte. The example is a great demonstration of the power of ref bindings.  This is an adaption of Three.js own documentation, and therefore it’s also a great way to learn how to translate what you already know how to do with imperative three.js, into declerative Threlte code.  Show Code App.svelte Scene.svelte Copy <script lang=\"ts\">   import { Canvas } from '@threlte/core'   import Scene from './Scene.svelte'   import { Pane, Button } from 'svelte-tweakpane-ui'   let reset: () => any | undefined </script> <Pane   title=\"LOD\"   position=\"fixed\" >   <Button     title=\"Reset Camera\"     on:click={reset}   /> </Pane> <div>   <Canvas>     <Scene bind:reset />   </Canvas> </div> <style>   div {     position: relative;     height: 100%;     width: 100%;   } </style> Copy <script>   import { T, useThrelte } from '@threlte/core'   import { OrbitControls } from '@threlte/extras'   let controls   export const reset = () => controls.reset() </script> <T.PerspectiveCamera   makeDefault   position={[0,0,25]}   lookAt.y={0} >   <OrbitControls enableZoom={true} bind:ref={controls} /> </T.PerspectiveCamera> <T.DirectionalLight position={[3, 10, 10]} /> <T.HemisphereLight intensity={0.2} /> <T.LOD let:ref={lod}>   {#each [\"red\",\"green\",\"blue\"] as color, i}     <T.Group on:create={({ref}) => {       lod.addLevel(ref, i*75)     }}>       <T.Mesh>         <T.IcosahedronGeometry args={[10,3-i]} />         <T.MeshStandardMaterial {color} wireframe />       </T.Mesh>       <T.Mesh>         <T.IcosahedronGeometry args={[10,3-i]} />         <T.MeshStandardMaterial {color} transparent opacity={0.3} />       </T.Mesh>     </T.Group>   {/each} </T.LOD> How does it work First <T> creates the geometry and material Then it attaches those to the mesh on:create will run later, but we remember to use a reference to the mesh itself ref and a reference lod to the parent LOD object.  … which happens 3 times due to the #each block  Copy <T.LOD let:ref={lod}>   {#each ['red', 'green', 'blue'] as color, i}     <T.Mesh       on:create={({ ref }) => {         lod.addLevel(ref, i * 75) // i * 75 = distance       }}     >       <T.IcosahedronGeometry args={[10, 3 - i]} />       <T.MeshStandardMaterial         {color}         wireframe       />     </T.Mesh>   {/each} </T.LOD> <T> now creates the LOD parent and internally calls the three.js function lod.add(child) on each mesh, since they are defined inside the <T.LOD> object. However, in three.js we need the lod.addLevel(child, distance) as well to register the children as LOD levels and not just attached children. This is where our on:create function comes in - upon creation of each mesh, we are able to call lod.addLevel(child, distance) Previous Page camera-controls Next Page Random Placement On this page How does it work Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/examples/geometry/rendering-points","title":"Rendering Points | Threlte Example","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  Misc Gaussian Splatting Tutorials Animating a Spaceship animation Animation Transitions camera Pointer Lock Controls ThirdPersonCamera camera-controls geometry LOD Random Placement Rendering Points Terrain with 3D noise Terrain with Rapier physics meshline Cursor Lines postprocessing Outlines renderers CSS2DRenderer Overlay shaders Interactive shader Rendering Points Show Code App.svelte Scene.svelte SceneAlternative.svelte Copy <script>   import { Canvas } from '@threlte/core'   import Scene from './Scene.svelte' </script> <div>   <Canvas>     <Scene />   </Canvas> </div> <style>   div {     height: 100%;   } </style> Using Points  Points work in Threlte the same way they do in Three. Check three docs about Points and Point Material to learn more.  Ensuring Points Work Correctly with BufferGeometry  For your points to function correctly, it’s essential that they have an associated BufferGeometry with a specified attribute for point positions. Here’s a straightforward method using the default Threlte approach:  Copy <T.Points>   <T.BufferGeometry>     <T.BufferAttribute       args={[positions, 3]}       attach={(parent, self) => {         parent.setAttribute('position', self)         return () => {           // cleanup function called when ref changes or the component unmounts           // https://threlte.xyz/docs/reference/core/t#attach         }       }}     />   </T.BufferGeometry>   <T.PointsMaterial size={0.25} /> </T.Points>  In the case of <T.BufferAttribute>, it is not enough to make it a child of <T.BufferGeometry>. To actually link it, you must invoke the attach method. If you skip this step, the attribute won’t be associated with the geometry. Learn more about how attach works.  Alternatively, you can also define and manage BufferGeometry within <script> tags or in an external file. Once done, the <T> component allows for direct attachment to <T.Points>, like so:  Copy <T.Points>   <T is={pointsBufferGeometry} />   <T.PointsMaterial size={0.25} /> </T.Points>  Working code for this approach can be found in SceneAlternative.svelte file of this example.  Previous Page Random Placement Next Page Terrain with 3D noise On this page Using Points Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/examples/postprocessing/outlines","title":"Outlines | Threlte Example","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  Misc Gaussian Splatting Tutorials Animating a Spaceship animation Animation Transitions camera Pointer Lock Controls ThirdPersonCamera camera-controls geometry LOD Random Placement Rendering Points Terrain with 3D noise Terrain with Rapier physics meshline Cursor Lines postprocessing Outlines renderers CSS2DRenderer Overlay shaders Interactive shader Outlines  Implements the Outline postprocessing pass. Vanilla threejs example here  An outlined cube loops through a maze, with a different outline color when the object is hidden.  Show Code App.svelte CustomRenderer.svelte Maze.svelte Scene.svelte Copy <script lang=\"ts\">   import { Canvas } from '@threlte/core'   import Scene from './Scene.svelte' </script> <div>   <Canvas>     <Scene />   </Canvas> </div> <style>   div {     height: 100%;   } </style> How it works In Scene.svelte Bind the mesh we want to outline, and pass it as prop selectedMesh to CustomRenderer component Postprocessing is performed within CustomRenderer component We use the ‘postprocessing’ library Create a new EffectComposer with Threlte’s renderer Then run our own render loop with this new render function, using useTask from threlte, make sure to set autoRender to false Our function setupEffectComposer adds the required RenderPass, and OutlinePass to the EffectComposer, specifically to our Mesh object This function will re-run if selectedMesh changes Animation of the cube is done with svelte/motion in Scene.svelte Previous Page Cursor Lines Next Page CSS2DRenderer Overlay On this page How it works Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/examples/renderers/css2drenderer-overlay","title":"CSS2DRenderer Overlay | Threlte Example","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  Misc Gaussian Splatting Tutorials Animating a Spaceship animation Animation Transitions camera Pointer Lock Controls ThirdPersonCamera camera-controls geometry LOD Random Placement Rendering Points Terrain with 3D noise Terrain with Rapier physics meshline Cursor Lines postprocessing Outlines renderers CSS2DRenderer Overlay shaders Interactive shader CSS2DRenderer Overlay  This example shows how to run an additional Three.js renderer in parallel with Threlte’s <Canvas>, while still leveraging Threlte’s built-in elements. Specifically, we’ll run CSS2DRenderer to add flat labels to objects in a three-dimensional scene.  This example can be easily adapted to use CSS3DRenderer instead, if you want the elements to live “inside” the scene, rather than flat across the surface.  Show Code App.svelte CounterLabel.svelte CssObject.svelte Scene.svelte Copy <script lang=\"ts\">   import { Canvas } from '@threlte/core'   import Scene from './Scene.svelte' </script> <div id=\"css-renderer-target\" /> <div id=\"main\">   <Canvas>     <Scene />   </Canvas> </div> <style>   div#main {     height: 100%;   }   #css-renderer-target {     left: 0;     position: absolute;     pointer-events: none;     top: 0;   } </style> Copy <script>   import { T } from '@threlte/core'   // A normal html svelte component, no relation the Threlte   export let label = ''   let count = 0   function click() { count++ } </script> <button on:click={click}>  {label} - {count} </button> <style>   button {     margin-left: 0.75rem;     border-radius: 0.25rem;     padding: 0.25rem 0.5rem;     pointer-events: auto;     background-image: linear-gradient(       #5e6cf4 0%,       #1338db 100%     );   } </style> Copy <script>   import { T } from '@threlte/core'   import { CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer'   export let pointerEvents = false   let element </script> <div   bind:this={element}   style:pointer-events={pointerEvents ? 'auto' : 'none !important'}   style:will-change=\"transform\" >   <slot /> </div> {#if element}   <T {...$$restProps} is={CSS2DObject} args={[element]} let:ref>     <slot name=\"three\" {ref} />   </T> {/if} Copy <script lang=\"ts\">   import { T, useStage, useTask, useThrelte } from '@threlte/core'   import { OrbitControls } from '@threlte/extras'   import { CSS2DRenderer } from 'three/addons/renderers/CSS2DRenderer.js'   import CounterLabel from './CounterLabel.svelte'   import CssObject from './CssObject.svelte'   const { scene, size, autoRenderTask, camera } = useThrelte()   // Set up the CSS2DRenderer to run in a div placed atop the <Canvas>   const element = document.querySelector('#css-renderer-target') as HTMLElement   const cssRenderer = new CSS2DRenderer({ element })   $: cssRenderer.setSize($size.width, $size.height)   // We are running two renderers, and don't want to run   // updateMatrixWorld twice; tell the renderers that we'll handle   // it manually.   // https://threejs.org/docs/#api/en/core/Object3D.updateWorldMatrix   scene.matrixWorldAutoUpdate = false   // To update the matrices *once* per frame, we'll use a task that is added   // right before the autoRenderTask. This way, we can be sure that the   // matrices are updated before the renderers run.   useTask(     () => {       scene.updateMatrixWorld()     },     { before: autoRenderTask }   )   // The CSS2DRenderer needs to be updated after the autoRenderTask, so we   // add a task that runs after it.   useTask(     () => {       // Update the DOM       cssRenderer.render(scene, camera.current)     },     {       after: autoRenderTask,       autoInvalidate: false     }   ) </script> <T.PerspectiveCamera   makeDefault   position={[5, 5, 5]} >   <OrbitControls enableDamping /> </T.PerspectiveCamera> <T.DirectionalLight position={[0, 10, 10]} /> <T.Mesh position.y={1}>   <T.BoxGeometry args={[2, 2, 2]} />   <T.MeshStandardMaterial color=\"#F64F6F\" /> </T.Mesh> <CssObject   position={[-1, 2, 1]}   center={[0, 0.5]} >   <CounterLabel label=\"Hello\" />   <T.Mesh slot=\"three\">     <T.SphereGeometry args={[0.25]} />     <T.MeshStandardMaterial color=\"#4F6FF6\" />   </T.Mesh> </CssObject> <CssObject   position={[1, 2, 1]}   center={[0, 0.5]} >   <CounterLabel label=\"CSS\" />   <T.Mesh slot=\"three\">     <T.SphereGeometry args={[0.25]} />     <T.MeshStandardMaterial color=\"#6FF64F\" />   </T.Mesh> </CssObject> <CssObject   position={[1, 2, -1]}   center={[0, 0.5]} >   <CounterLabel label=\"Renderer\" />   <T.Mesh slot=\"three\">     <T.SphereGeometry args={[0.25]} />     <T.MeshStandardMaterial color=\"#F64F6F\" />   </T.Mesh> </CssObject> How does it work?  In this scene, we run two renderers - the default one provided by Threlte, and a new CSS2DRenderer which we initialize manually. Threlte’s renderer runs on a canvas element as usual, while our new renderer runs in a <div> with absolute positioning on top of it.  The render loop  To integrate the a new renderer into svelte’s loop, we call it inside a task added right after Threlte’s autoRenderTask. For details on how to use the Threlte Task Scheduling System, see the documentation.  By default, each renderer traverses the scene and updates every object. We can set scene.matrixWorldAutoUpdate to false and manually call scene.updateMatrixWorld() each tick in order to avoid duplicating the work, since we’re running two renderers. To do that, we’re adding a task that runs right before Threlte’s autoRenderTask.  Scene.svelte Copy <script>   const { scene, size, autoRenderTask, camera } = useThrelte()   // Set up the CSS2DRenderer to run in a div placed atop the <Canvas>   const element = document.querySelector('#css-renderer-target') as HTMLElement   const cssRenderer = new CSS2DRenderer({ element })   $: cssRenderer.setSize($size.width, $size.height)   // We are running two renderers, and don't want to run   // updateMatrixWorld twice; tell the renderers that we'll handle   // it manually.   // https://threejs.org/docs/#api/en/core/Object3D.updateWorldMatrix   scene.matrixWorldAutoUpdate = false   // To update the matrices *once* per frame, we'll use a task that is added   // right before the autoRenderTask. This way, we can be sure that the   // matrices are updated before the renderers run.   useTask(     () => {       scene.updateMatrixWorld()     },     { before: autoRenderTask }   )   // The CSS2DRenderer needs to be updated after the autoRenderTask, so we   // add a task that runs after it.   useTask(     () => {       // Update the DOM       cssRenderer.render(scene, camera.current)     },     {       after: autoRenderTask,       autoInvalidate: false     }   ) </script> Setting up CssObject  The other integral part is a component that accepts DOM contents in the default slot and places them in the scene and renders them with the ThreeJS CSS2DRenderer:  CssObject.svelte Copy <script>   import { T } from '@threlte/core'   import { CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer'   export let pointerEvents = false   let element </script> <div   bind:this={element}   style:pointer-events={pointerEvents ? 'auto' : 'none !important'}   style:will-change=\"transform\" >   <slot /> </div> {#if element}   <T {...$$restProps} is={CSS2DObject} args={[element]} let:ref /> {/if}  This component renders children into a div, and allows nested Threlte components via the three slot. It passes all other properties through, letting us use it like so:  Copy <CssObject position={[-1, 2, 1]} center={[-0.2, 0.5]}>   <CounterLabel label=\"Hello\" />   <T.Mesh slot=\"three\">     <T.SphereGeometry args={[0.25]} />     <T.MeshStandardMaterial color=\"#4F6FF6\" />   </T.Mesh> </CssObject>  where <CounterLabel> is a normal Svelte component outside Threlte’s control, but the mesh is a component inside the scene hooked in with slot=\"three\".  Previous Page Outlines Next Page Interactive shader On this page How does it work? The render loop Setting up CssObject Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/examples/animation/animation-transitions","title":"Animation Transitions | Threlte Example","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  Misc Gaussian Splatting Tutorials Animating a Spaceship animation Animation Transitions camera Pointer Lock Controls ThirdPersonCamera camera-controls geometry LOD Random Placement Rendering Points Terrain with 3D noise Terrain with Rapier physics meshline Cursor Lines postprocessing Outlines renderers CSS2DRenderer Overlay shaders Interactive shader Animation Transitions  Transition seamlessly between GLTF animations.  Show Code App.svelte Character.svelte Scene.svelte state.ts Copy <script lang=\"ts\">   import { Pane, Button } from 'svelte-tweakpane-ui'   import { Canvas } from '@threlte/core'   import Scene from './Scene.svelte'   import { buttonIdle, buttonWalk, buttonRun } from './state' </script> <Pane   title=\"Transitions\"   position=\"fixed\" >   <Button     title=\"Idle\"     on:click={() => {       $buttonIdle = !$buttonIdle }} /> <Button title=\"Walk\" on:click={() => { $buttonWalk = !$buttonWalk }} /> <Button title=\"Run\" on:click={() => { $buttonRun = !$buttonRun }} /> </Pane> <div> <Canvas> <Scene /> </Canvas> </div> <style> div { position: relative; height: 100%; width: 100%; } </style> Explanation glTF is a comprehensive file format for 3D models, and it supports animations. In this example, we extract the animations from the gltf file, play them, and crossfade between them. What is the code doing? Extract the variables gltf and actions; const { gltf, actions } = useGltfAnimations() Bind gltf to the <GLTF> component, Copy <GLTF bind:gltf={$gltf}   url=\"https://threejs.org/examples/models/gltf/Xbot.glb\" />  this causes actions to be populated with an array of the available animations in that gltf file  run console.log(Object.entries($actions)) to see the available action strings, and the shape of the animation object. By doing this, you’ll discover that this example is only using 3 of the 7 available animations attached to this gltf file. selecting a different animation calls transitionTo function, which crossfades between the two animations Previous Page Animating a Spaceship Next Page Pointer Lock Controls On this page Explanation What is the code doing? Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/examples/shaders/interactive-shader","title":"Interactive shader | Threlte Example","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex Search Misc Gaussian Splatting Tutorials Animating a Spaceship animation Animation Transitions camera Pointer Lock Controls ThirdPersonCamera camera-controls geometry LOD Random Placement Rendering Points Terrain with 3D noise Terrain with Rapier physics meshline Cursor Lines postprocessing Outlines renderers CSS2DRenderer Overlay shaders Interactive shader Interactive shader In this tutorial, we’ll walk you through the process of configuring a shader-based material while leveraging Threlte’s built-in interactivity plugin. Specifically, you’ll learn how to dynamically adjust material uniforms based on user interactions—such as clicking on the mesh. Show Code App.svelte fragment.glsl Scene.svelte vertex.glsl Copy <script lang=\"ts\"> import { Canvas } from '@threlte/core' import Scene from './Scene.svelte' </script> <div> <span class=\"absolute top-0 left-0 z-20 whitespace-nowrap pl-4\">Click on the terrain mesh</span> <Canvas> <Scene /> </Canvas> </div> <style> div { height: 100%; } </style> Copy <script lang=\"ts\"> import { T } from '@threlte/core' import { OrbitControls } from '@threlte/extras' import { createNoise2D } from 'simplex-noise' import { PlaneGeometry, Vector3 } from 'three' import { DEG2RAD } from 'three/src/math/MathUtils' import fragmentShader from './fragment.glsl?raw' import vertexShader from './vertex.glsl?raw' import { interactivity } from '@threlte/extras' import { quadOut } from 'svelte/easing' import { tweened } from 'svelte/motion' // Terrain setup const terrainSize = 30 const geometry = new PlaneGeometry(terrainSize, terrainSize, 100, 100) const noise = createNoise2D() const vertices = geometry.getAttribute('position').array for (let i = 0; i < vertices.length; i += 3) { const x = vertices[i] const y = vertices[i + 1] // @ts-ignore vertices[i + 2] = noise(x / 5, y / 5) _ 2 + noise(x / 40, y / 40) _ 3 } geometry.computeVertexNormals() // Interactivity and shader variables interactivity() const pulsePosition = new Vector3() const pulseTimer = tweened(0, { easing: quadOut }) </script> <T.PerspectiveCamera makeDefault position={[-70, 50, 10]} fov={15} > <OrbitControls     autoRotate     target.y={1.5}     autoRotateSpeed={0.2}   /> </T.PerspectiveCamera> <T.Mesh {geometry} rotation.x={DEG2RAD _ -90} on:click={({ point }) => { pulsePosition.set(point.x, point.y, point.z) pulseTimer.set(0, { duration: 0 }) pulseTimer.set(1, { duration: 2000 }) }} > <T.ShaderMaterial {fragmentShader} {vertexShader} uniforms={{       pulseTimer: {         value: 0       },       pulsePosition: {         value: pulsePosition       }     }} uniforms.pulseTimer.value={$pulseTimer} /> </T.Mesh> Copy // Credit: https://madebyevan.com/shaders/grid/ varying vec2 vUv; varying vec3 vPosition; uniform vec3 pulsePosition; uniform float pulseTimer; void main() { float coord = vPosition.y _ 2.; float line = abs(fract(coord - 0.5) - 0.5) / fwidth(coord); float lineFill = 1.0 - min(line, 1.0); lineFill = pow(lineFill, 1.0 / 2.2); float circleGrowTimer = min(pulseTimer _ 2., 1.); float colorFadeTimer = 1. - pulseTimer; float circle = 1.0 - smoothstep(0.9 _ circleGrowTimer, 1. _ circleGrowTimer, length(pulsePosition.xz - vPosition.xz) _ 0.05); // bright colors vec3 color = vec3(vPosition.y _ 1.5, vUv.x, vUv.y) _ 2.5; vec3 coloredLines = (color _ colorFadeTimer _ lineFill); vec3 final = coloredLines = mix(coloredLines, vec3(lineFill _ 0.1), 1. - circle _ colorFadeTimer); gl*FragColor = vec4(final, 1.); } Copy varying vec2 vUv; varying vec3 vPosition; void main() { vec4 modelPosition = modelMatrix * vec4(position, 1.0); vec4 viewPosition = viewMatrix * modelPosition; vec4 projectedPosition = projectionMatrix * viewPosition; gl_Position = projectedPosition; vUv = uv; vPosition = (modelMatrix * vec4(position, 1.0)).xyz; } How does it work? We’ll start this example by utilizing the mesh terrain established in one of our other examples, Terrain with 3D noise, as our foundational starting point. Making shader material To integrate the shader-based material into your terrain mesh, simply nest the <T.ShaderMaterial/> component as a child element. It’s essential to supply both fragmentShader and vertexShader props, formatted as strings. In our example, these shaders are isolated into individual files — fragment.glsl for the fragment shader and vertex.glsl for the vertex shader. We leverage Vite’s ?raw special query to import these as plain strings. Although your build tool and setup might differ, this modular approach enhances code readability. Alternatively, you could provide these shaders directly as JavaScript strings. Scene.svelte Copy <script> import fragmentShader from './fragment.glsl?raw' import vertexShader from './vertex.glsl?raw' </script> <T.Mesh {geometry} rotation.x={DEG2RAD * -90} <T.ShaderMaterial {fragmentShader} {vertexShader} /> </T.Mesh> Setting up terrain interactivity In this step, we set up interactivity for the Terrain Mesh. The aim is to trigger a shader animation when the user clicks on the mesh, thereby updating its variables in real-time. To accomplish this, we first import and initialize the interactivity plugin. This extends the functionality of your mesh by enabling on:click events, akin to the familiar HTML events in Svelte. For our animation, it’s crucial to pinpoint the exact location where the user clicks on the mesh. The event generated by the plugin conveniently provides us with a point variable to identify this location. Scene.svelte Copy <script> import { interactivity } from '@threlte/extras' interactivity() </script> <T.Mesh {geometry} rotation.x={DEG2RAD * -90} on:click={({ point }) => { console.log('user clicked on', point) }} > <T.ShaderMaterial {fragmentShader} {vertexShader} /> </T.Mesh> Making shader interactive With event listeners now active on our mesh, the next step is to capture these events into variables and forward them to the shader as uniforms. Our shader will require two uniform variables: one for the click position (pulsePosition as a Vector3) and another for tracking the animation timeline (pulseTimer). To manage the timeline, we’ll employ a Svelte store using the tweened function. Both pulsePosition and pulseTimer will be updated based on the on:click event we previously implemented. Configuring uniforms for our ShaderMaterial is straightforward and closely aligns with standard Three.js practices. While pulsePosition can be directly passed into the uniforms and will auto-update, a current limitation in the store implementation requires us to set an initial value of 0 for pulseTimer. To update it, we’ll use a pierced property: uniforms.pulseTimer.value={$pulseTimer}.  You can learn more about ShaderMaterial from Three.js ShaderMaterial docs  Scene.svelte Copy <script>   import { quadOut } from 'svelte/easing'   import { tweened } from 'svelte/motion'   const pulsePosition = new Vector3()   const pulseTimer = tweened(0, {     easing: quadOut   }) </script> <T.Mesh   {geometry}   rotation.x={DEG2RAD * -90}   on:click={({ point }) => {     pulsePosition.set(point.x, point.y, point.z)     pulseTimer.set(0, {       duration: 0     })     pulseTimer.set(1, {       duration: 2000     })   }} >   <T.ShaderMaterial     {fragmentShader}     {vertexShader}     uniforms={{       pulseTimer: {         value: 0       },       pulsePosition: {         value: pulsePosition       }     }}     uniforms.pulseTimer.value={$pulseTimer} /> </T.Mesh> How do the Fragment and Vertex shaders work? While a deep dive into shader mechanics falls beyond the scope of this tutorial, let’s take a moment for a brief conceptual overview: Vertex Shader: At its core, we have a straightforward vertex shader that forwards the world position of the material to the fragment shader. This is achieved using a varying vPosition variable, along with UV coordinates transferred through a varying vUv variable. Fragment Shader and User Interaction: Armed with knowledge of the material’s world position, we can dynamically render a circle originating from the pulsePosition uniform, which is set by the user’s click event. As time progresses, the circle’s radius expands, controlled by the pulseTimer uniform. If you want to learn more about how to write shaders, the Book of Shaders is an excellent resource to start with. Previous Page CSS2DRenderer Overlay On this page How does it work? Making shader material Setting up terrain interactivity Making shader interactive How do the Fragment and Vertex shaders work? Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/examples/geometry/random-placement","title":"Random Placement | Threlte Example","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex Search Misc Gaussian Splatting Tutorials Animating a Spaceship animation Animation Transitions camera Pointer Lock Controls ThirdPersonCamera camera-controls geometry LOD Random Placement Rendering Points Terrain with 3D noise Terrain with Rapier physics meshline Cursor Lines postprocessing Outlines renderers CSS2DRenderer Overlay shaders Interactive shader Random Placement This example explores several simple ways to automatically position objects in your scene. This is a great starting point if you want to procedurally generate terrain or other scenes. Taking these methods as a starting point, you’ll hopefully be able to find the approach that suits your project. Manually placing objects is also a good enough approach in many projects. A hybrid approach involves starting out with random scenery, and then saving all the object properties to create a static scene from it. Basic Random The simplest starting point is using Math.random as is. Every object will be independently placed, this is called a uniform distribution. Starting with a plane, a couple of svelte’s {#each ... as ...} blocks and some random numbers; you can position objects like in the simple scene below. Show Code assets birch.svelte bush.svelte rock.svelte tree.svelte App.svelte Random.svelte Scene.svelte stores.ts Copy <script> import { Canvas } from '@threlte/core' import Scene from './Scene.svelte' import { Pane, Button, Slider } from 'svelte-tweakpane-ui' import { regen, numberOfObjects } from './stores' </script> <Pane title=\"Completely Random\" position=\"fixed\" > <Button title=\"regenerate\" on:click={() => { $regen = !$regen }} /> <Slider bind:value={$numberOfObjects}     label=\"Number of Objects\"     min={20}     max={100}     step={10}   /> </Pane> <div>   <Canvas>     <Scene />   </Canvas> </div> <style>   div {     height: 100%;   } </style> Preventing Object Overlap  There is a limitation in using just Math.random: it does not prevent objects from overlapping. This means that sometimes you’ll see a tree growing from a rock, or two bushes growing into each other.  In order to prevent this you can use Poisson disk sampling. This algorithm guarantees a minimum distance between your objects.  Show Code assets bush.svelte App.svelte Random.svelte sampling.ts Scene.svelte stores.ts Copy <script>   import { Canvas } from '@threlte/core'   import Scene from './Scene.svelte'   import { Pane, Button, Slider } from 'svelte-tweakpane-ui'   import { regen, radius } from './stores' </script> <Pane   title=\"Poisson Disc Sampling\"   position=\"fixed\" >   <Button     title=\"regenerate\"     on:click={() => {       $regen = !$regen }} /> <Slider bind:value={$radius}     label=\"Min Distance Between Objects\"     min={1}     max={6}     step={0.5}   /> </Pane> <div>   <Canvas>     <Scene />   </Canvas> </div> <style>   div {     height: 100%;   } </style>  If you reduce the minimum distance to something smaller than your objects size then there will look like there’s collisions. For the bushes in this example, even a distance of 1 still looks good.  Different object sizes  In many scenes this approach works well. However, sometimes you’ll want different spacing for different objects: a large tree needs more space than a small bush. Below is a variation of poisson disc sampling, but this time it allows for some different spacing, depending on the object type.  Show Code assets birch.svelte bush.svelte rock.svelte tree.svelte App.svelte Random.svelte sampling.ts Scene.svelte stores.ts Copy <script>   import { Canvas } from '@threlte/core'   import Scene from './Scene.svelte'   import { Pane, Button } from 'svelte-tweakpane-ui'   import { regen, radius } from './stores' </script> <Pane   title=\"Adjusted Sampling\"   position=\"fixed\" >   <Button     title=\"regenerate\"     on:click={() => {       $regen = !$regen }} /> </Pane> <div> <Canvas> <Scene /> </Canvas> </div> <style> div { height: 100%; } </style> An important parameter to play with when generating scenes with this last approach is the window size. It is inferred from the difference between the largest and smallest radius given. You’ll need to play around with the details if your usecase starts running into performance issues because of this algorithm. Previous Page LOD Next Page Rendering Points On this page Basic Random Preventing Object Overlap Different object sizes Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/examples/camera/camera-controls","title":"camera-controls | Threlte Example","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex Search Misc Gaussian Splatting Tutorials Animating a Spaceship animation Animation Transitions camera Pointer Lock Controls ThirdPersonCamera camera-controls geometry LOD Random Placement Rendering Points Terrain with 3D noise Terrain with Rapier physics meshline Cursor Lines postprocessing Outlines renderers CSS2DRenderer Overlay shaders Interactive shader camera-controls You may have come up against limitations with <OrbitalControls/> from three.js. Camera Controls is an existing project which supports smooth transitions and has many more features. The example below has a component with a basic implementation of camera-controls and functions equivelant to this camera-controls doc example. Your project may need specific features in which case, visit their docs and adjust the component to suit. The camera-controls package features include first-person, third-person, pointer-lock, fit-to-bounding-sphere and much more! Show Code App.svelte CameraControls.svelte CameraControls.svelte.d.ts Scene.svelte stores.ts useControlsContext.ts Copy <script> import { Canvas } from '@threlte/core' import Scene from './Scene.svelte' import { useTweakpane } from '$lib/useTweakpane'   import { cameraControls, mesh } from './stores'   import { DEG2RAD } from 'three/src/math/MathUtils'   let camera   $: if ($cameraControls) { camera = $cameraControls._camera   }   const { action, addButton, addSeparator } = useTweakpane({     title: 'Camera Controls',     expanded: false   })   addButton({     title: 'rotate theta 45deg',     label: '',     onClick: () => {       $cameraControls.rotate(45 * DEG2RAD, 0, true)     }   })   addButton({     title: 'rotate theta -90deg',     label: '',     onClick: () => {       $cameraControls.rotate(-90 * DEG2RAD, 0, true)     }   })   addButton({     title: 'rotate theta 360deg',     label: '',     onClick: () => {       $cameraControls.rotate(360 * DEG2RAD, 0, true)     }   })   addButton({     title: 'rotate phi 20deg',     label: '',     onClick: () => {       $cameraControls.rotate(0, 20 * DEG2RAD, true)     }   })   addSeparator()   addButton({     title: 'truck(1, 0)',     label: '',     onClick: () => {       $cameraControls.truck(1, 0, true)     }   })   addButton({     title: 'truck(0, 1)',     label: '',     onClick: () => {       $cameraControls.truck(0, 1, true)     }   })   addButton({     title: 'truck(-1, -1)',     label: '',     onClick: () => {       $cameraControls.truck(-1, -1, true)     }   })   addSeparator()   addButton({     title: 'dolly 1',     label: '',     onClick: () => {       $cameraControls.dolly(1, true)     }   })   addButton({     title: 'dolly -1',     label: '',     onClick: () => {       $cameraControls.dolly(-1, true)     }   })   addSeparator()   addButton({     title: 'zoom `camera.zoom / 2`',     label: '',     onClick: () => {       $cameraControls.zoom(camera.zoom / 2, true)     }   })   addButton({     title: 'zoom `- camera.zoom / 2`',     label: '',     onClick: () => {       $cameraControls.zoom(-camera.zoom / 2, true)     }   })   addSeparator()   addButton({     title: 'move to ( 3, 5, 2)',     label: '',     onClick: () => {       $cameraControls.moveTo(3, 5, 2, true)     }   })   addButton({     title: 'fit to the bounding box of the mesh',     label: '',     onClick: () => {       $cameraControls.fitToBox($mesh, true) } }) addSeparator() addButton({ title: 'move to ( -5, 2, 1 )', label: '', onClick: () => { $cameraControls.setPosition(-5, 2, 1, true)     }   })   addButton({     title: 'look at ( 3, 0, -3 )',     label: '',     onClick: () => {       $cameraControls.setTarget(3, 0, -3, true)     }   })   addButton({     title: 'move to ( 1, 2, 3 ), look at ( 1, 1, 0 )',     label: '',     onClick: () => {       $cameraControls.setLookAt(1, 2, 3, 1, 1, 0, true)     }   })   addSeparator()   addButton({     title: 'move to somewhere between ( -2, 0, 0 ) -> ( 1, 1, 0 ) and ( 0, 2, 5 ) -> ( -1, 0, 0 )',     label: '',     onClick: () => {       $cameraControls.lerpLookAt(-2, 0, 0, 1, 1, 0, 0, 2, 5, -1, 0, 0, Math.random(), true)     }   })   addSeparator()   addButton({     title: 'reset',     label: '',     onClick: () => {       $cameraControls.reset(true)     }   })   addButton({     title: 'saveState',     label: '',     onClick: () => {       $cameraControls.saveState()     }   })   addSeparator()   addButton({     title: 'disable mouse/touch controls',     label: '',     onClick: () => {       $cameraControls.enabled = false     }   })   addButton({     title: 'enable mouse/touch controls',     label: '',     onClick: () => {       $cameraControls.enabled = true     }   }) </script> <div use:action /> <div>   <Canvas>     <Scene />   </Canvas> </div> <style>   :global(body) {     margin: 0;   }   div {     width: 100%;     height: 100%;   } </style> Previous Page ThirdPersonCamera Next Page LOD Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/examples/camera/thirdpersoncamera","title":"ThirdPersonCamera | Threlte Example","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  Misc Gaussian Splatting Tutorials Animating a Spaceship animation Animation Transitions camera Pointer Lock Controls ThirdPersonCamera camera-controls geometry LOD Random Placement Rendering Points Terrain with 3D noise Terrain with Rapier physics meshline Cursor Lines postprocessing Outlines renderers CSS2DRenderer Overlay shaders Interactive shader ThirdPersonCamera  Inspired by SimonDev’s ThirdPersonCamera.  Use ‘W’ and ‘S’ to move forward and backwards, and ‘A’ and ‘D’ to rotate the camera.  Show Code App.svelte Player.svelte Scene.svelte ThirdPersonControls.svelte Copy <script lang=\"ts\">   import { Pane, Text } from 'svelte-tweakpane-ui'   import { Canvas } from '@threlte/core'   import { World } from '@threlte/rapier'   import Scene from './Scene.svelte' </script> <Pane   position=\"fixed\"   title=\"third-person\" >   <Text     value=\"Use the 'wasd' keys to move around\"     disabled   /> </Pane> <div>   <Canvas>     <World>       <Scene />     </World>   </Canvas> </div> <style>   div {     position: relative;     height: 100%;     width: 100%;   } </style> Previous Page Pointer Lock Controls Next Page camera-controls Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/reference/core/use-render","title":"useRender | @threlte/core","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  @threlte/core Getting Started COMPONENTS <Canvas> <T> HOOKS useThrelte useStage useTask useLoader useThrelteUserContext HELPERS Plugins Utilities Hierarchy LEGACY useFrame useRender @threlte/core useRender  This hook is deprecated and will be removed in the next major release. Please use useTask instead. See the migration guide for more information.  This hook allows you to execute code on every invalidated frame and after all useFrame hooks have been executed. You receive the state (the same as useThrelte) and a clock delta in seconds. Typically this hook is used to implement advanced rendering techniques such as post processing or custom render passes.  As soon as this hook is used anywhere in the component tree, the default render loop is disabled. You need to take care of rendering yourself.  You may pass additional options to this hook. The property order is useful if you need to order the sequence of useRender callbacks across the component tree where callbacks are ordered from low to high.  Copy type ThrelteUseRenderOptions = {   order?: number } Basic Rendering Renderer.svelte Copy <script>   import { useRender } from '@threlte/core'   useRender(({ camera, renderer, scene }, delta) => {     renderer.render(scene, camera.current)   }) </script>  The state available in the callback is the same as the one available with useThrelte. Some properties (such as the property camera) use a CurrentWritable store. which is a custom Threlte store. It’s a regular writable store that also has a current property which is the current value of the store. It’s useful for accessing the value of a store in a non-reactive context, such as in loops.  Post Processing  This example demonstrates how to use useRender to implement post processing effects using the library postprocessing.  When using SvelteKit (or more broadly, SSR) be sure to add ssr: { noExternal: [ 'postprocessing' ] } to your vite.config.js.  Renderer.svelte Copy <script>   import { useThrelte, useRender } from '@threlte/core'   import {     EffectComposer,     EffectPass,     RenderPass,     SMAAEffect,     SMAAPreset,     BloomEffect,     KernelSize   } from 'postprocessing'   const { scene, renderer, camera, size } = useThrelte()   // To use the EffectComposer we need to pass arguments to the   // default WebGLRenderer: https://github.com/pmndrs/postprocessing#usage   const composer = new EffectComposer(renderer)   const setupEffectComposer = (camera) => {     composer.removeAllPasses()     composer.addPass(new RenderPass(scene, camera))     composer.addPass(       new EffectPass(         camera,         new BloomEffect({           intensity: 1,           luminanceThreshold: 0.15,           height: 512,           width: 512,           luminanceSmoothing: 0.08,           mipmapBlur: true,           kernelSize: KernelSize.MEDIUM         })       )     )     composer.addPass(       new EffectPass(         camera,         new SMAAEffect({           preset: SMAAPreset.LOW         })       )     )   }   // We need to set up the passes according to the camera in use   $: setupEffectComposer($camera) $: composer.setSize($size.width, $size.height) useRender((*, delta) => { composer.render(delta) }) </script> Previous Page useFrame Next Page Getting Started On this page Basic Rendering Post Processing Contribute Contribution Guide Go To Source Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/reference/core/getting-started#installation","title":"Getting Started | @threlte/core","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex Search @threlte/core Getting Started COMPONENTS <Canvas> <T> HOOKS useThrelte useStage useTask useLoader useThrelteUserContext HELPERS Plugins Utilities Hierarchy LEGACY useFrame useRender @threlte/core Getting Started The package @threlte/core is the core package of the Threlte framework. It provides the basic functionality of the framework, such as the <Canvas> and <T> components, and hooks to interact with the Threlte state. Installation Terminal Copy npm install @threlte/core three @types/three Usage Every Threlte application must be wrapped in a <Canvas> component. This component is responsible for creating THREE.WebGLRenderer and providing a state for every child component. App.svelte Copy <script lang=\"ts\"> import { Canvas } from '@threlte/core' import Scene from './Scene.svelte' </script> <Canvas> <Scene /> </Canvas> The main building block of a Threlte application is the <T> component. Use this component to instantiate any Three.js object available in the THREE namespace. Scene.svelte Copy <script lang=\"ts\"> import { T } from '@threlte/core' </script> <T.PerspectiveCamera position={[10, 10, 10]} on:create={({ ref }) => { ref.lookAt(0, 0, 0) }} /> <T.Mesh> <T.BoxGeometry args={[1, 1, 1]} /> <T.MeshBasicMaterial color=\"red\" /> </T.Mesh> Next Page Components On this page Installation Usage Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/reference/core/canvas","title":"<Canvas> | @threlte/core","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex Search @threlte/core Getting Started COMPONENTS <Canvas> <T> HOOKS useThrelte useStage useTask useLoader useThrelteUserContext HELPERS Plugins Utilities Hierarchy LEGACY useFrame useRender @threlte/core <Canvas> The <Canvas> component is the root of your Threlte scene. It provides contexts that all other components and many hooks are depending on. This means they need to be child components to the <Canvas> component. Structuring Your App Check out our guide on structuring your app for a fail-safe app architecture recipe. By default, the <canvas> element and the renderer will resize to fit the parent element whenever the window resizes. Provide the property size to set a fixed <canvas> size. <Canvas> also provides a default camera, located at { z: 5 }. If renderMode is set to on-demand (default) property changes to components and other changes that are picked up by Threlte automatically invalidate the current frame. If renderMode is set to always a re-render is automatically scheduled every frame. If renderMode is set to manual a re-render must manually be triggered with useThrelte().advance(). Component Signature Props name type required default description autoRender boolean no true Whether to automatically render the scene every frame. Set to `false` to implement custom render pipelines. colorManagementEnabled boolean no true colorSpace THREE.ColorSpace no srgb dpr number no window.devicePixelRatio rendererParameters THREE.WebGLRendererParameters no renderMode 'always' | 'on-demand' | 'manual' no 'on-demand' shadows boolean | THREE.ShadowMapType no THREE.PCFSoftShadowMap size { width: number, height: number } no If not provided, the dimensions of the parent element will be used. toneMapping THREE.ToneMapping no THREE.ACESFilmicToneMapping renderer.toneMapping useLegacyLights boolean no true Whether to use legacy lighting mode or physically correct lighting mode. Physically correct lighting mode is more physically accurate, but legacy lighting mode may be more intuitive. Bindings name type ctx ThrelteContext Previous Page Components Next Page <T> On this page Component Signature Contribute Contribution Guide Go To Source Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/reference/core/use-threlte-user-context","title":"useThrelteUserContext | @threlte/core","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex Search @threlte/core Getting Started COMPONENTS <Canvas> <T> HOOKS useThrelte useStage useTask useLoader useThrelteUserContext HELPERS Plugins Utilities Hierarchy LEGACY useFrame useRender @threlte/core useThrelteUserContext The UserContext is a store scoped to the context of your root <Canvas> component and can be used to store and retrieve arbitrary data from anywhere in the Threlte app. The UserContext contains UserContextEntries, which are arbitrary objects in a certain namespace. Because it’s scoped, it’s especially interesting for authoring reusable components and inter-component communication. In fact, the components <OrbitControls> and <TransformControls> from '@threlte/extras' use this method to communicate with each other. useThrelteUserContext can set and get the user context store at the same time. Get the user context store If no namespace is provided, the whole user context store is returned. Copy <script> import { useThrelteUserContext } from '@threlte/core' const userCtx = useThrelteUserContext() console.log($userCtx) // -> { 'some-context': { foo: 'bar' } } </script>  If a namespace is provided, the hook returns a derived store.  Copy <script>   import { useThrelteUserContext } from '@threlte/core'   const ctx = useThrelteUserContext('some-context')   console.log($ctx) // -> { foo: 'bar' } </script> Set the user context store If a UserContextEntry is passed to the hook, and the namespace is not set, the UserContextEntry is set at the namespace and the UserContextEntry is returned. If a UserContextEntry is passed to the hook, and the namespace is set, by default the UserContextEntry is not set and the existing UserContextEntry is returned. Copy <script> import { useThrelteUserContext } from '@threlte/core' const getCtx = () => { return { foo: 'bar' } } const ctx = useThrelteUserContext('some-context', getCtx) console.log(ctx) // -> { foo: 'bar' } </script> By default, when a context is set at a given namespace, setting it again will be ignored. You can override this behaviour: Copy <script> import { useThrelteUserContext } from '@threlte/core' const getCtx = () => { return { foo: 'bar' } } const ctx = useThrelteUserContext('some-context', getCtx, { exising: 'merge' }) console.log(ctx) // -> { foo: 'bar' } </script> Previous Page useLoader Next Page Helpers On this page Get the user context store Set the user context store Contribute Contribution Guide Go To Source Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/reference/core/use-frame","title":"useFrame | @threlte/core","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex Search @threlte/core Getting Started COMPONENTS <Canvas> <T> HOOKS useThrelte useStage useTask useLoader useThrelteUserContext HELPERS Plugins Utilities Hierarchy LEGACY useFrame useRender @threlte/core useFrame This hook is deprecated and will be removed in the next major release. Please use useTask instead. See the migration guide for more information. This hook allows you to execute code on every frame as part of the Threlte Task Scheduling System. You receive the state (the same as useThrelte) and a clock delta in seconds. Your callback function will be invoked just before a frame is rendered. When the component unmounts it is unsubscribed automatically from the frame loop. You may pass additional options to this hook. The property order is useful if you need to order the sequence of useFrame callbacks across the component tree where callbacks are ordered from low to high. Copy type ThrelteUseFrameOptions = { autostart?: boolean order?: number invalidate?: boolean } useFrame returns an object containing functions start and stop to control the execution of the callback and a store started to subscribe to its state. Example Starting and stopping the execution of a handler: Copy const { start, stop, started } = useFrame( () => { console.log('rendering…') }, { autostart: false } ) const toggleUseFrame = () => { if ($started) {     stop()   } else {     start()   } }  Accessing the context and the global clocks delta inside a handler:  Copy useFrame(({ camera }, delta) => {   const cameraPosition = camera.current.position })  The state available in the callback is the same as the one available with useThrelte. Some properties (such as the property camera) use a CurrentWritable store. which is a custom Threlte store. It’s a regular writable store that also has a current property which is the current value of the store. It’s useful for accessing the value of a store in a non-reactive context, such as in loops.  By default, useFrame will invalidate every frame and trigger a render after the callback is executed. You can disable this behavior by setting invalidate to false and using the function invalidate from the state to trigger a render manually.  Copy useFrame(   ({ invalidate }) => {     // manually invalidate the frame     invalidate()   },   {     invalidate: false   } ) Previous Page Legacy Next Page useRender On this page Example Contribute Contribution Guide Go To Source Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/reference/core/hierarchy","title":"Hierarchy | @threlte/core","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  @threlte/core Getting Started COMPONENTS <Canvas> <T> HOOKS useThrelte useStage useTask useLoader useThrelteUserContext HELPERS Plugins Utilities Hierarchy LEGACY useFrame useRender @threlte/core Hierarchy  This component is mostly used internally and is not required for most use cases.  To control adding and removing components from the scene graph there’s the following component:  <HierarchicalObject>  A simple extension of the <HierarchicalObject> is the <SceneGraphObject>.  For most other use cases the <Portal> component is what your looking for.  Previous Page Utilities Next Page Legacy Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/reference/core/use-stage","title":"useStage | @threlte/core","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  @threlte/core Getting Started COMPONENTS <Canvas> <T> HOOKS useThrelte useStage useTask useLoader useThrelteUserContext HELPERS Plugins Utilities Hierarchy LEGACY useFrame useRender @threlte/core useStage  Tasks are part of Threlte’s Task Scheduling System. For details on how to use stages and tasks, see the scheduling tasks page.  The hook useStage can be used to create or retrieve a stage. Stages are groups of tasks. They are executed in a specific order.  Creating a Stage  useStage will create a stage if it does not exist yet, or return the existing stage if it does.  Copy const { renderStage } = useThrelte() // All tasks added to the stage `afterRenderStage` // will be executed after the tasks of the stage `renderStage`. const afterRenderStage = useStage('after-render', {   after: renderStage })  Be aware that useStage never removes a stage as that’s usually not needed. If a stage is created once in your Threlte app, it’s available throughout the app’s lifetime. If you want to remove a stage, you can do so by calling removeStage on the scheduler instance returned by useThrelte.  A stage decides when and how its tasks are executed. By default, a stage will execute its tasks on every frame. You can change this behavior by passing a callback option to useStage. This callback will be called every frame. The first argument delta is the time elapsed since the last frame. The second argument runTasks is a function that when invoked will run all the tasks of the stage in their respective order. You can use it to run the tasks only when needed (e.g. when a condition is met) or to run them multiple times. If a number is passed as the first argument to runTasks, the tasks will receive that as the delta.  Copy const { renderStage } = useThrelte() const conditionalStage = useStage('after-render', {   after: renderStage,   callback: (delta, runTasks) => {       // This callback will be called every frame. The first argument is the time elapsed       // since the last frame. The second argument is a function that will run all the       // tasks of the stage. You can use it to run the tasks only when needed (e.g. when       // a condition is met) or to run them multiple times. If a number is passed as the       // first argument to runTasks, the tasks will receive that as the delta.       if (condition) {         runTasks()       }     } }) Examples Implement Performance Profiling  This component will implement three-perf. It expects you to call a function perf.begin() before any frame callbacks are executed and perf.end() after all frame callbacks have been executed, including rendering. Assuming our app didn’t add any other stages, we add a stage that runs before Threlte’s mainStage (making it the first stage) and another stage that runs after Threlte’s renderStage (making it the last stage). We then call perf.begin() in a task of the first stage and perf.end() in a task of the second stage.  ThreePerf.svelte Copy <script>   import { useStage, useTask, useThrelte } from '@threlte/core'   import { ThreePerf } from 'three-perf'   const { renderer, mainStage, renderStage } = useThrelte()   const perf = new ThreePerf({     anchorX: 'left',     anchorY: 'top',     domElement: document.body,     renderer   })   const beforeMainStage = useStage('three-perf-begin', {     before: mainStage   })   useTask(() => {     perf.begin()   }, { stage: beforeMainStage })   const afterRenderStage = useStage('three-perf-end', {     after: renderStage   })   useTask(() => {     perf.end()   }, { stage: afterRenderStage }) </script> Previous Page useThrelte Next Page useTask On this page Creating a Stage Examples Implement Performance Profiling Contribute Contribution Guide Go To Source Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/reference/core/getting-started#usage","title":"Getting Started | @threlte/core","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  @threlte/core Getting Started COMPONENTS <Canvas> <T> HOOKS useThrelte useStage useTask useLoader useThrelteUserContext HELPERS Plugins Utilities Hierarchy LEGACY useFrame useRender @threlte/core Getting Started  The package @threlte/core is the core package of the Threlte framework. It provides the basic functionality of the framework, such as the <Canvas> and <T> components, and hooks to interact with the Threlte state.  Installation Terminal Copy npm install @threlte/core three @types/three Usage  Every Threlte application must be wrapped in a <Canvas> component. This component is responsible for creating THREE.WebGLRenderer and providing a state for every child component.  App.svelte Copy <script lang=\"ts\">   import { Canvas } from '@threlte/core'   import Scene from './Scene.svelte' </script> <Canvas>   <Scene /> </Canvas>  The main building block of a Threlte application is the <T> component. Use this component to instantiate any Three.js object available in the THREE namespace.  Scene.svelte Copy <script lang=\"ts\">   import { T } from '@threlte/core' </script> <T.PerspectiveCamera   position={[10, 10, 10]}   on:create={({ ref }) => {     ref.lookAt(0, 0, 0)   }} /> <T.Mesh>   <T.BoxGeometry args={[1, 1, 1]} />   <T.MeshBasicMaterial color=\"red\" /> </T.Mesh> Next Page Components On this page Installation Usage Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/reference/core/utilities","title":"Utilities | @threlte/core","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  @threlte/core Getting Started COMPONENTS <Canvas> <T> HOOKS useThrelte useStage useTask useLoader useThrelteUserContext HELPERS Plugins Utilities Hierarchy LEGACY useFrame useRender @threlte/core Utilities  Threlte comes with a few utilities that are catered towards the use in a Threlte application but can also be used in other projects.  watch  Watch a single store or multiple stores and call a callback when they change to trigger side effects. The callback will be called immediately with the current value of the store.  Copy const store = writable(0) watch(store, (value) => {   console.log(value) // 0 }) This utility function needs to be called during component initialization.  You can also watch multiple stores:  Copy const store1 = writable(0) const store2 = writable(1) watch([store1, store2], ([value1, value2]) => {   console.log(value1, value2) // 0 1 })  The callback can return a cleanup function that will be called when the stores change again.  Copy const store = writable(0) watch(store, (value) => {   console.log(value) // 0   return () => {     console.log('cleanup')   } }) memoize  Use a single store or multiple stores and return the value(s) as an object. This is useful for using stores in a non-reactive way e.g. in loops.  Copy const numberStore = writable(0) const memoized = memoize(numberStore) // { current: 0 } useTask(() => {   numberStore.update((n) => n + 1)   console.log(memoized.current) // 1, 2, 3, ... }) const stringStore = writable('hello') const memoized = memoize([numberStore, stringStore]) console.log(memoized.current) // [0, 'hello'] This utility function needs to be called during component initialization.  You can also pass a transform function to transform the values:  Copy const store = writable(0) const doubled = memoize(store, (n) => n * 2) // { current: 0 } useTask(() => {   store.update((n) => n + 1)   console.log(doubled.current) // 2, 4, 6, ... }) asyncWritable  Creates a writable store that is initialized with a promise. The store also directly implements the then and catch methods of the promise so that it can be used in await expressions and {#await} blocks of Svelte.  Copy <script>   import { asyncWritable } from '@threlte/core'   const asyncOperation = async () => {     // Do something async   }   const store = asyncWritable(asyncOperation())   $: console.log($store) // asyncOperation result </script> <h1> {#await store then data} // Do something with the data {/await} </h1> This type of store is the return type of the load function of useLoader. If an error occurs in the promise, the error will be logged to the console and the error can be accessed via the error property of the store which is also a store. Copy <script> import { asyncWritable } from '@threlte/core' const asyncOp = async () => { throw new Error('Something went wrong') } const store = asyncWritable(asyncOp()) const error = store.error $: console.log($store) // undefined $: console.log($error) // Error: Something went wrong </script> currentWritable A writable store that also has a current property that is updated synchronously. For use in non-reactive contexts e.g. loops where unwrapping a store every frame (with Svelte’s get method) is expensive. Copy const store = currentWritable(0) useTask(() => { console.log(store.current) // 0 }) forwardEventHandlers Natively, Svelte has no way of passing down event handlers inside a component to a child component. Events have to be hand-wired upstream. This function allows you to forward event handlers from a parent component to a child component as if they were declared on the child component itself. Child.svelte Copy <script> import { forwardEventHandlers } from '@threlte/core' const dispatchingComponent = forwardEventHandlers() </script> <OtherChildComponent bind:this={$dispatchingComponent} /> Now, when implementing <Child> and adding event handlers via on:eventname, those event handlers will be forwarded to <OtherChildComponent>: Parent.svelte Copy <script> import Child from './Child.svelte' </script> <Child on:click={() => console.log('clicked')} /> If OtherChildComponent.svelte now dispatches a click event, the event handler in Parent.svelte will be called. createRawEventDispatcher This event dispatcher creates raw events unlike Svelte’s own event dispatcher which nests the data in a detail object (CustomEvent<Payload>). This is not nesessary for a lot of Threlte use cases and makes it harder to work with the payload. ComponentA.svelte Copy <script> const dispatch = createRawEventDispatcher<{ foo: string }>() dispatch('foo', 'bar') </script> ComponentB.svelte Copy <ComponentA on:foo={(e) => console.log(e)} /> <!-- 'bar' --> Previous Page Plugins Next Page Hierarchy On this page watch memoize asyncWritable currentWritable forwardEventHandlers createRawEventDispatcher Contribute Contribution Guide Go To Source Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/reference/core/use-task","title":"useTask | @threlte/core","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex Search @threlte/core Getting Started COMPONENTS <Canvas> <T> HOOKS useThrelte useStage useTask useLoader useThrelteUserContext HELPERS Plugins Utilities Hierarchy LEGACY useFrame useRender @threlte/core useTask Tasks are part of Threlte’s Task Scheduling System. For details on how to use stages and tasks, see the scheduling tasks page. The hook useTask is used to create a task that is used to run code on every frame. Creating an Anonymous Task In its most basic form, useTask takes a callback function as its argument. This function will be executed on every frame, starting on the next frame. It receives a delta, representing the time since the last frame as its argument. By default, the created task is added to Threlte’s mainStage in an arbitrary order (i.e. without dependencies). Copy const { start, stop, started, task } = useTask((delta) => { // This function will be executed on every frame }) It returns an object with the following properties: start: A function that starts the task. It will be executed on the next frame. Note that by default a task is started automatically. stop: A function that stops the task. It will not be executed on the next frame. started: A boolean Svelte Readable store indicating whether the task is started or not. task: The task itself. You can use it to indicate a dependency to this task on another task. Creating a Keyed Task You can key a task by passing it as the first argument to useTask. This makes referencing this task easier across your app. The key can be any string or symbol value that is unique across all tasks in the stage it is added to. Copy const { start, stop, started, task: someTask } = useTask('some-task', (delta) => { // This function will be executed on every frame }) Creating a Task in a Stage You can pass a stage that the task should be added to as an option to useTask, the stage can be passed by value or key. If no stage is passed, the task will be added to Threlte’s mainStage. Copy useTask((delta) => { // This function will be executed on every frame as a // task in the stage `afterRenderStage`. }, { stage: afterRenderStage }) Task Dependencies A common use case for tasks is to run code after another task has been executed. Imagine a game where an object is transformed by user input in one task and a camera follows that object in another task. The camera task should be executed after the object has been transformed. To control the order in which tasks are executed in a stage, you can pass a before and after option to useTask. The tasks passed to these options are called dependencies and can be a task itself, the key of a task or an array of tasks or keys. The referenced tasks must be in the same stage as the task you are creating. Task dependencies can be created in any order if they are passed by key. This means that you can declare a dependency (with before or after) on a task that is created later in your code. The declared dependencies will be taken into account when they are created later on. If a task is passed by reference to the before or after option, the task created by useTask will automatically be added to the same stage as the task it depends on. If you pass a key instead and the task you want to reference is not in Threlte’s mainStage, you will also need to pass the stage, either by value or key. Examples Starting and Stopping Tasks By default, a task is started automatically. You can set it to not start automatically by passing autoStart: false as an option to useTask. You can then start and stop the task manually using the start and stop functions: Copy const { start, stop, started } = useTask((delta) => { // do something }, { autoStart: false }) // start the task start() // stop the task stop() // check if the task is started $: console.log($started) useTask and On-Demand Rendering By default, useTask will automatically invalidate the current frame and thereby request a re-render on the next frame. Most of the times, this is what you want. However, if you want more control over when things are re-rendered, you can pass autoInvalidate: false as an option to useTask. This will prevent the task from automatically invalidating the current frame. You can then invalidate the frame manually using the invalidate function returned by useThrelte: Copy const { invalidate } = useThrelte() const { start, stop, started } = useTask((delta) => { // do something // invalidate the current frame if (someCondition) { invalidate() } }, { autoInvalidate: false }) Update Objects To update objects in your scene, you can use the useTask hook to create a task that is executed on every frame. The delta time is passed as the first argument to make animations frame rate independent. Copy <script> import { T, useTask } from '@threlte/core' import { Mesh } from 'svelte-three' let mesh useTask((delta) => { if (!mesh) return mesh.rotation.y += delta * 0.5 }) </script> <T.Mesh bind:ref={mesh}> <T.BoxGeometry /> </T.Mesh> Custom Render Pipeline To create a custom render pipeline, add a task to Threlte’s renderStage which by default only runs its tasks when a re-render is needed. Be sure to set the property autoRender to false on the <Canvas> component or inside the <Renderer> component to prevent Threlte from automatically rendering your scene. CustomRenderer.svelte Copy <script> import { useTask, useThrelte } from '@threlte/core' import { onMount } from 'svelte' const { renderStage, autoRender } = useThrelte() // disable auto rendering onMount(() => { let before = autoRender.current autoRender.set(false) return () => autoRender.set(before) }) useTask((delta) => { // render your scene here }, { stage: renderStage, autoInvalidate: false }) </script> Post Processing This example demonstrates how to use useTask to implement post processing effects using the library postprocessing. Create a <Renderer> component. Be sure to set the option autoInvalidate of useTask to false to prevent Threlte from automatically invalidating the render stage. Renderer.svelte Copy <script> import { useThrelte, useTask } from '@threlte/core' import { onMount } from 'svelte' import { EffectComposer, EffectPass, RenderPass, SMAAEffect, SMAAPreset, BloomEffect, KernelSize } from 'postprocessing' const { scene, renderer, camera, size } = useThrelte() // Adapt the default WebGLRenderer: https://github.com/pmndrs/postprocessing#usage const composer = new EffectComposer(renderer) const setupEffectComposer = (camera) => { composer.removeAllPasses() composer.addPass(new RenderPass(scene, camera)) composer.addPass( new EffectPass( camera, new BloomEffect({ intensity: 1, luminanceThreshold: 0.15, height: 512, width: 512, luminanceSmoothing: 0.08, mipmapBlur: true, kernelSize: KernelSize.MEDIUM }) ) ) composer.addPass( new EffectPass( camera, new SMAAEffect({ preset: SMAAPreset.LOW }) ) ) } // We need to set up the passes according to the camera in use $: setupEffectComposer($camera) $: composer.setSize($size.width, $size.height)   const { renderStage, autoRender } = useThrelte()   // We need to disable auto rendering as soon as this component is   // mounted and restore the previous state when it is unmounted.   onMount(() => {     let before = autoRender.current     autoRender.set(false)     return () => autoRender.set(before)   })   useTask((delta) => {     composer.render(delta)   }, { stage: renderStage, autoInvalidate: false }) </script> Use the <Renderer> component in your app. To disable automatic rendering of your scene, Set autoRender to false on the <Canvas> component. App.svelte Copy <script>   import { Canvas } from '@threlte/svelte'   import Renderer from './Renderer.svelte' </script> <Canvas>   <Renderer /> </Canvas>  When using SvelteKit (or more broadly, SSR) be sure to add ssr: { noExternal: ['postprocessing' ]} to your vite.config.js.  Previous Page useStage Next Page useLoader On this page Creating an Anonymous Task Creating a Keyed Task Creating a Task in a Stage Task Dependencies Examples Starting and Stopping Tasks useTask and On-Demand Rendering Update Objects Custom Render Pipeline Post Processing Contribute Contribution Guide Go To Source Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/reference/core/components","title":"Components | @threlte/core","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  @threlte/core Getting Started COMPONENTS <Canvas> <T> HOOKS useThrelte useStage useTask useLoader useThrelteUserContext HELPERS Plugins Utilities Hierarchy LEGACY useFrame useRender @threlte/core Components Previous Page Getting Started Next Page <Canvas> Contribute Contribution Guide Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/reference/core/use-loader","title":"useLoader | @threlte/core","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex  Search  @threlte/core Getting Started COMPONENTS <Canvas> <T> HOOKS useThrelte useStage useTask useLoader useThrelteUserContext HELPERS Plugins Utilities Hierarchy LEGACY useFrame useRender @threlte/core useLoader  A hook to load data with an arbitrary THREE loader class. The result of load is cached and subsequent calls with the same arguments will yield the same return value (i.e. the same reference) across the entire Threlte app. The hook can use async loaders (using loader.loadAsync) as well as sync/callback-based loaders (using loader.load) and will default to the async version if available.  Copy const loader = useLoader(AudioLoader) const soundA = loader.load('audio/ambient_ocean.ogg') // -> `soundA` is an AsyncWritable<AudioBuffer> that // resolves/is populated once the asset is loaded. // somewhere else … const soundB = loader.load('audio/ambient_ocean.ogg') // -> `soundB` is also an AsyncWritable<AudioBuffer> // that resolves/is populated with the same reference // as `soundA` once the asset is loaded. Instantiating A Loader  A loader must always be instantiated at the top level of a component. This is because the loader is depending on an application-wide cache:  Copy <script>   import { useLoader } from '@threlte/core'   import { TextureLoader } from 'three'   const loader = useLoader(TextureLoader) </script>  A loader can be extended, to add custom features:  Copy <script>   import { useLoader } from '@threlte/core'   import { TextureLoader } from 'three'   const loader = useLoader(CustomTextureLoader, {     extend: (loader) => {       // do something with the loader, e.g. add DRACO support for       // GLTFLoader or add custom headers for TextureLoader.     }   }) </script>  If the constructor of a particular loader accepts arguments, they must be passed as an array to the option args of the second argument to useLoader:  Copy <script>   import { useLoader, useThrelte } from '@threlte/core'   import { SplatLoader } from '@pmndrs/vanilla'   const { renderer } = useThrelte()   const loader = useLoader(SplatLoader, {     args: [renderer]   })   // This resembles the following:   // const loader = new SplatLoader(renderer) </script> Loading An Asset Copy <script>   import { useLoader } from '@threlte/core'   import { TextureLoader } from 'three'   const texture = useLoader(TextureLoader).load('path/to/texture.png')   // A loader must always be instantiated at the top level of a component.   const { load } = useLoader(TextureLoader)   const onSomeEvent = () => {     // To load an asset outside of the top level, use the `load` method.     const texture = load('path/to/texture.png')   } </script>  The return type of load is a custom Threlte store called AsyncWritable and can be used as a regular Svelte store. Its initial value is undefined and will be updated once the asset is loaded.  The store also exposes the underlying promise methods then and catch and can therefore be directly awaited:  Copy <script>   import { useLoader, T } from '@threlte/core'   import { TextureLoader } from 'three'   const { load } = useLoader(TextureLoader)   const onSomeEvent = async () => {     // Load an asset and await the result.     const texture = await load('path/to/texture.png')   } </script> <!-- Or make use of Svelte's await block --> {#await load('path/to/texture.png') then map}   <T.MeshStandardMaterial {map} /> {/await} Loading Multiple Assets  The function load of useLoader also accepts an array of paths in which case the return value is an array of loaded assets:  Copy <script>   import { useLoader } from '@threlte/core'   import { TextureLoader } from 'three'   const { load } = useLoader(TextureLoader)   const textures = load(['texture1.png', 'texture2.png'])   $: console.log($textures) // [Texture, Texture] </script> Keep in mind that the store will be updated and the promise resolves once all assets are loaded. You can also provide a map of paths to load multiple assets at once. In this case the return value is a map of the loaded assets: Copy <script> import { useLoader } from '@threlte/core' import { TextureLoader } from 'three' const { load } = useLoader(TextureLoader) const textures = load({ texture1: 'texture1.png', texture2: 'texture2.png' }) $: console.log($textures) // { texture1: Texture, texture2: Texture } </script> Transforming The Result Caching The result of the transformation is cached and subsequent calls will return the same result. The load method accepts an optional second argument to transform the result of the loader: Copy <script> import { useLoader } from '@threlte/core' import { TextureLoader } from 'three' const { load } = useLoader(TextureLoader) const texture = load('path/to/texture.png', { transform: (texture) => { // do something with the texture return texture } }) </script> The return type of the transformation is used to infer the return type of the load method. Previous Page useTask Next Page useThrelteUserContext On this page Instantiating A Loader Loading An Asset Loading Multiple Assets Transforming The Result Contribute Contribution Guide Go To Source Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/reference/core/use-threlte","title":"useThrelte | @threlte/core","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex Search @threlte/core Getting Started COMPONENTS <Canvas> <T> HOOKS useThrelte useStage useTask useLoader useThrelteUserContext HELPERS Plugins Utilities Hierarchy LEGACY useFrame useRender @threlte/core useThrelte This hook lets you consume the main Threlte context (ThrelteContext) of your application (scoped to the root <Canvas>) which contains the renderer, camera, scene and other properties. Use this hook to manually invalidate the current frame … Copy const { invalidate } = useThrelte() invalidate() … access the renderer or the currently active camera … Copy const { renderer, camera } = useThrelte() console.log(renderer, $camera) … or update render properties: Copy const { toneMapping } = useThrelte() toneMapping.set(THREE.LinearToneMapping) Usage This hook relies on context passed down by the <Canvas> component and can only be used in a child of that component. Copy const { size, // Readable<Size> camera, // CurrentWritable<Camera> scene, // Scene dpr, // CurrentWritable<number> useLegacyLights, // CurrentWritable<boolean> renderer, // WebGLRenderer renderMode, // CurrentWritable<'always' | 'on-demand' | 'manual'> autoRender, // CurrentWritable<boolean> invalidate, // () => void advance, // () => void scheduler, // Scheduler mainStage, // Stage renderStage, // Stage autoRenderTask, // Task shouldRender, // () => boolean colorManagementEnabled, // CurrentWritable<boolean> colorSpace, // CurrentWritable<ColorSpace> toneMapping, // CurrentWritable<ToneMapping> shadows // CurrentWritable<boolean | ShadowMapType> } = useThrelte() renderMode If the renderMode is set to 'on-demand' and you are manually editing objects or materials, be sure to invalidate the current frame to request a rerender: Copy const { invalidate } = useThrelte() invalidate() If the renderMode is set to 'manual' you must manually trigger a re-render: Copy const { advance } = useThrelte() advance() The property can be changed at any time, but it will only take effect on the next frame. Previous Page Hooks Next Page useStage On this page Usage renderMode Contribute Contribution Guide Go To Source Edit this page Community Join us on Discord Threlte on Twitter"},{"url":"https://threlte.xyz/docs/reference/core/plugins","title":"Plugins | @threlte/core","date":"2024-01-16","content":"Learn Examples core extras gltf rapier theatre xr flex Search @threlte/core Getting Started COMPONENTS <Canvas> <T> HOOKS useThrelte useStage useTask useLoader useThrelteUserContext HELPERS Plugins Utilities Hierarchy LEGACY useFrame useRender @threlte/core Plugins Plugins are one of Threlte’s superpowers. Plugins allow you to globally extend Threlte’s <T> component functionality. This means you can not only add arbitrary props and event handlers to your <T> components but also override the default behavior of the <T> component entirely. Plugins add code to every <T> component instance. That code acts as if it were part of the <T> component itself. You have full access to props, event listeners and the component instance itself. For an advanced example of what a plugin can do, see the interactivity plugin of @threlte/extras. injectPlugin The function injectPlugin adds a plugin to all descendant <T> components of the component that invokes it. This means that you can add plugins to a specific part of your scene graph without affecting the rest of the scene graph. Copy import { injectPlugin } from '@threlte/core' injectPlugin('plugin-name', ({ ref, props }) => { // We are *inside\* a `<T>` component instance // Do something with the ref and props // e.g. return early if the plugin is not applicable return { // These props are reserved for this plugin, the // `<T>` component instance will not act on them. pluginProps: ['plugin-prop-a', 'plugin-prop-b'], // this function is called whenever the `ref` inside the `<T>` // component changes. You may return a cleanup function that is // called when the ref changes again or the component unmounts. onRefChange: (ref) => { // Do something with the ref return () => { // Cleanup } }, // This function is called whenever the $$props of the `<T>` component     // change. These include props like \"dispose\", \"args\" and \"makeDefault\"     // that are part of the component itself rather than the props that are     // passed to the Three.js object.     onPropsChange: (props) => {       // Do something with the props     },     // This function is called whenever the $$restProps of the `<T>` component // change. These are the props that are passed to the Three.js object. onRestPropsChange: (restProps) => { // Do something with the restProps } } }) You may also override a plugin namespace further down the tree by calling injectPlugin again with the same plugin name. injectPlugin is relying on a context provided by your root <Canvas> component and can therefore only be used inside a <Canvas> component. createPlugin The function createPlugin creates a NamedPlugin but does not add it to the global plugin list and therefore does not make it available to all <T> components. This is useful if you want to create a plugin at some place and inject it at another. plugin.ts Copy import { createPlugin } from '@threlte/core' export const plugin = createPlugin('plugin-name', ({ ref, props }) => { // Plugin Code }) Component.svelte Copy <script lang=\"ts\"> import { injectPlugin } from '@threlte/core' import { plugin } from './plugin' injectPlugin(plugin) </script> Previous Page Helpers Next Page Utilities On this page injectPlugin createPlugin Contribute Contribution Guide Go To Source Edit this page Community Join us on Discord Threlte on Twitter"}]
